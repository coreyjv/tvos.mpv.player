// Generated from player/lua/ytdl_hook.lua

"local utils = require 'mp.utils'\n"
"local msg = require 'mp.msg'\n"
"local options = require 'mp.options'\n"
"\n"
"local o = {\n"
"    exclude = \"\",\n"
"    try_ytdl_first = false,\n"
"    use_manifests = false\n"
"}\n"
"options.read_options(o)\n"
"\n"
"local ytdl = {\n"
"    path = \"youtube-dl\",\n"
"    searched = false,\n"
"    blacklisted = {}\n"
"}\n"
"\n"
"local chapter_list = {}\n"
"\n"
"function Set (t)\n"
"    local set = {}\n"
"    for _, v in pairs(t) do set[v] = true end\n"
"    return set\n"
"end\n"
"\n"
"local safe_protos = Set {\n"
"    \"http\", \"https\", \"ftp\", \"ftps\",\n"
"    \"rtmp\", \"rtmps\", \"rtmpe\", \"rtmpt\", \"rtmpts\", \"rtmpte\",\n"
"    \"data\"\n"
"}\n"
"\n"
"local function exec(args)\n"
"    local ret = utils.subprocess({args = args})\n"
"    return ret.status, ret.stdout, ret\n"
"end\n"
"\n"
"-- return true if it was explicitly set on the command line\n"
"local function option_was_set(name)\n"
"    return mp.get_property_bool(\"option-info/\" ..name.. \"/set-from-commandline\",\n"
"                                false)\n"
"end\n"
"\n"
"-- return true if the option was set locally\n"
"local function option_was_set_locally(name)\n"
"    return mp.get_property_bool(\"option-info/\" ..name.. \"/set-locally\", false)\n"
"end\n"
"\n"
"-- youtube-dl may set special http headers for some sites (user-agent, cookies)\n"
"local function set_http_headers(http_headers)\n"
"    if not http_headers then\n"
"        return\n"
"    end\n"
"    local headers = {}\n"
"    local useragent = http_headers[\"User-Agent\"]\n"
"    if useragent and not option_was_set(\"user-agent\") then\n"
"        mp.set_property(\"file-local-options/user-agent\", useragent)\n"
"    end\n"
"    local additional_fields = {\"Cookie\", \"Referer\", \"X-Forwarded-For\"}\n"
"    for idx, item in pairs(additional_fields) do\n"
"        local field_value = http_headers[item]\n"
"        if field_value then\n"
"            headers[#headers + 1] = item .. \": \" .. field_value\n"
"        end\n"
"    end\n"
"    if #headers > 0 and not option_was_set(\"http-header-fields\") then\n"
"        mp.set_property_native(\"file-local-options/http-header-fields\", headers)\n"
"    end\n"
"end\n"
"\n"
"local function append_libav_opt(props, name, value)\n"
"    if not props then\n"
"        props = {}\n"
"    end\n"
"\n"
"    if name and value and not props[name] then\n"
"        props[name] = value\n"
"    end\n"
"\n"
"    return props\n"
"end\n"
"\n"
"local function edl_escape(url)\n"
"    return \"%\" .. string.len(url) .. \"%\" .. url\n"
"end\n"
"\n"
"local function url_is_safe(url)\n"
"    local proto = type(url) == \"string\" and url:match(\"^(.+)://\") or nil\n"
"    local safe = proto and safe_protos[proto]\n"
"    if not safe then\n"
"        msg.error((\"Ignoring potentially unsafe url: '%s'\"):format(url))\n"
"    end\n"
"    return safe\n"
"end\n"
"\n"
"local function time_to_secs(time_string)\n"
"    local ret\n"
"\n"
"    local a, b, c = time_string:match(\"(%d+):(%d%d?):(%d%d)\")\n"
"    if a ~= nil then\n"
"        ret = (a*3600 + b*60 + c)\n"
"    else\n"
"        a, b = time_string:match(\"(%d%d?):(%d%d)\")\n"
"        if a ~= nil then\n"
"            ret = (a*60 + b)\n"
"        end\n"
"    end\n"
"\n"
"    return ret\n"
"end\n"
"\n"
"local function extract_chapters(data, video_length)\n"
"    local ret = {}\n"
"\n"
"    for line in data:gmatch(\"[^\\r\\n]+\") do\n"
"        local time = time_to_secs(line)\n"
"        if time and (time < video_length) then\n"
"            table.insert(ret, {time = time, title = line})\n"
"        end\n"
"    end\n"
"    table.sort(ret, function(a, b) return a.time < b.time end)\n"
"    return ret\n"
"end\n"
"\n"
"local function is_blacklisted(url)\n"
"    if o.exclude == \"\" then return false end\n"
"    if #ytdl.blacklisted == 0 then\n"
"        local joined = o.exclude\n"
"        while joined:match('%|?[^|]+') do\n"
"            local _, e, substring = joined:find('%|?([^|]+)')\n"
"            table.insert(ytdl.blacklisted, substring)\n"
"            joined = joined:sub(e+1)\n"
"        end\n"
"    end\n"
"    if #ytdl.blacklisted > 0 then\n"
"        url = url:match('https?://(.+)')\n"
"        for _, exclude in ipairs(ytdl.blacklisted) do\n"
"            if url:match(exclude) then\n"
"                msg.verbose('URL matches excluded substring. Skipping.')\n"
"                return true\n"
"            end\n"
"        end\n"
"    end\n"
"    return false\n"
"end\n"
"\n"
"local function parse_yt_playlist(url, json)\n"
"    -- return 0-based index to use with --playlist-start\n"
"\n"
"    if not json.extractor or json.extractor ~= \"youtube:playlist\" then\n"
"        return nil\n"
"    end\n"
"\n"
"    local query = url:match(\"%?.+\")\n"
"    if not query then return nil end\n"
"\n"
"    local args = {}\n"
"    for arg, param in query:gmatch(\"(%a+)=([^&?]+)\") do\n"
"        if arg and param then\n"
"            args[arg] = param\n"
"        end\n"
"    end\n"
"\n"
"    local maybe_idx = tonumber(args[\"index\"])\n"
"\n"
"    -- if index matches v param it's probably the requested item\n"
"    if maybe_idx and #json.entries >= maybe_idx and\n"
"        json.entries[maybe_idx].id == args[\"v\"] then\n"
"        msg.debug(\"index matches requested video\")\n"
"        return maybe_idx - 1\n"
"    end\n"
"\n"
"    -- if there's no index or it doesn't match, look for video\n"
"    for i = 1, #json.entries do\n"
"        if json.entries[i] == args[\"v\"] then\n"
"            msg.debug(\"found requested video in index \" .. (i - 1))\n"
"            return i - 1\n"
"        end\n"
"    end\n"
"\n"
"    msg.debug(\"requested video not found in playlist\")\n"
"    -- if item isn't on the playlist, give up\n"
"    return nil\n"
"end\n"
"\n"
"local function make_absolute_url(base_url, url)\n"
"    if url:find(\"https?://\") == 1 then return url end\n"
"\n"
"    local proto, domain, rest =\n"
"        base_url:match(\"(https?://)([^/]+/)(.*)/?\")\n"
"    local segs = {}\n"
"    rest:gsub(\"([^/]+)\", function(c) table.insert(segs, c) end)\n"
"    url:gsub(\"([^/]+)\", function(c) table.insert(segs, c) end)\n"
"    local resolved_url = {}\n"
"    for i, v in ipairs(segs) do\n"
"        if v == \"..\" then\n"
"            table.remove(resolved_url)\n"
"        elseif v ~= \".\" then\n"
"            table.insert(resolved_url, v)\n"
"        end\n"
"    end\n"
"    return proto .. domain ..\n"
"        table.concat(resolved_url, \"/\")\n"
"end\n"
"\n"
"local function join_url(base_url, fragment)\n"
"    local res = \"\"\n"
"    if base_url and fragment.path then\n"
"        res = make_absolute_url(base_url, fragment.path)\n"
"    elseif fragment.url then\n"
"        res = fragment.url\n"
"    end\n"
"    return res\n"
"end\n"
"\n"
"local function edl_track_joined(fragments, protocol, is_live, base)\n"
"    if not (type(fragments) == \"table\") or not fragments[1] then\n"
"        msg.debug(\"No fragments to join into EDL\")\n"
"        return nil\n"
"    end\n"
"\n"
"    local edl = \"edl://\"\n"
"    local offset = 1\n"
"    local parts = {}\n"
"\n"
"    if (protocol == \"http_dash_segments\") and\n"
"        not fragments[1].duration and not is_live then\n"
"        -- assume MP4 DASH initialization segment\n"
"        table.insert(parts,\n"
"            \"!mp4_dash,init=\" .. edl_escape(join_url(base, fragments[1])))\n"
"        offset = 2\n"
"\n"
"        -- Check remaining fragments for duration;\n"
"        -- if not available in all, give up.\n"
"        for i = offset, #fragments do\n"
"            if not fragments[i].duration then\n"
"                msg.error(\"EDL doesn't support fragments\" ..\n"
"                         \"without duration with MP4 DASH\")\n"
"                return nil\n"
"            end\n"
"        end\n"
"    end\n"
"\n"
"    for i = offset, #fragments do\n"
"        local fragment = fragments[i]\n"
"        if not url_is_safe(join_url(base, fragment)) then\n"
"            return nil\n"
"        end\n"
"        table.insert(parts, edl_escape(join_url(base, fragment)))\n"
"        if fragment.duration then\n"
"            parts[#parts] =\n"
"                parts[#parts] .. \",length=\"..fragment.duration\n"
"        end\n"
"    end\n"
"    return edl .. table.concat(parts, \";\") .. \";\"\n"
"end\n"
"\n"
"local function has_native_dash_demuxer()\n"
"    local demuxers = mp.get_property_native(\"demuxer-lavf-list\", {})\n"
"    for _, v in ipairs(demuxers) do\n"
"        if v == \"dash\" then\n"
"            return true\n"
"        end\n"
"    end\n"
"    return false\n"
"end\n"
"\n"
"local function valid_manifest(json)\n"
"    local reqfmt = json[\"requested_formats\"] and json[\"requested_formats\"][1] or {}\n"
"    if not reqfmt[\"manifest_url\"] and not json[\"manifest_url\"] then\n"
"        return false\n"
"    end\n"
"    local proto = reqfmt[\"protocol\"] or json[\"protocol\"] or \"\"\n"
"    return (proto == \"http_dash_segments\" and has_native_dash_demuxer()) or\n"
"        proto:find(\"^m3u8\")\n"
"end\n"
"\n"
"local function add_single_video(json)\n"
"    local streamurl = \"\"\n"
"    local max_bitrate = 0\n"
"    local reqfmts = json[\"requested_formats\"]\n"
"\n"
"    -- prefer manifest_url if present\n"
"    if o.use_manifests and valid_manifest(json) then\n"
"        local mpd_url = reqfmts and reqfmts[1][\"manifest_url\"] or\n"
"            json[\"manifest_url\"]\n"
"        if not mpd_url then\n"
"            msg.error(\"No manifest URL found in JSON data.\")\n"
"            return\n"
"        elseif not url_is_safe(mpd_url) then\n"
"            return\n"
"        end\n"
"\n"
"        streamurl = mpd_url\n"
"\n"
"        if reqfmts then\n"
"            for _, track in pairs(reqfmts) do\n"
"                max_bitrate = track.tbr > max_bitrate and\n"
"                    track.tbr or max_bitrate\n"
"            end\n"
"        elseif json.tbr then\n"
"            max_bitrate = json.tbr > max_bitrate and json.tbr or max_bitrate\n"
"        end\n"
"\n"
"    -- DASH/split tracks\n"
"    elseif reqfmts then\n"
"        for _, track in pairs(reqfmts) do\n"
"            local edl_track = nil\n"
"            edl_track = edl_track_joined(track.fragments,\n"
"                track.protocol, json.is_live,\n"
"                track.fragment_base_url)\n"
"            if not edl_track and not url_is_safe(track.url) then\n"
"                return\n"
"            end\n"
"            if track.acodec and track.acodec ~= \"none\" then\n"
"                -- audio track\n"
"                mp.commandv(\"audio-add\",\n"
"                    edl_track or track.url, \"auto\",\n"
"                    track.format_note or \"\")\n"
"            elseif track.vcodec and track.vcodec ~= \"none\" then\n"
"                -- video track\n"
"                streamurl = edl_track or track.url\n"
"            end\n"
"        end\n"
"\n"
"    elseif not (json.url == nil) then\n"
"        local edl_track = nil\n"
"        edl_track = edl_track_joined(json.fragments, json.protocol,\n"
"            json.is_live, json.fragment_base_url)\n"
"\n"
"        if not edl_track and not url_is_safe(json.url) then\n"
"            return\n"
"        end\n"
"        -- normal video or single track\n"
"        streamurl = edl_track or json.url\n"
"        set_http_headers(json.http_headers)\n"
"    else\n"
"        msg.error(\"No URL found in JSON data.\")\n"
"        return\n"
"    end\n"
"\n"
"    msg.debug(\"streamurl: \" .. streamurl)\n"
"\n"
"    mp.set_property(\"stream-open-filename\", streamurl:gsub(\"^data:\", \"data://\", 1))\n"
"\n"
"    mp.set_property(\"file-local-options/force-media-title\", json.title)\n"
"\n"
"    -- set hls-bitrate for dash track selection\n"
"    if max_bitrate > 0 and\n"
"        not option_was_set(\"hls-bitrate\") and\n"
"        not option_was_set_locally(\"hls-bitrate\") then\n"
"        mp.set_property_native('file-local-options/hls-bitrate', max_bitrate*1000)\n"
"    end\n"
"\n"
"    -- add subtitles\n"
"    if not (json.requested_subtitles == nil) then\n"
"        for lang, sub_info in pairs(json.requested_subtitles) do\n"
"            msg.verbose(\"adding subtitle [\"..lang..\"]\")\n"
"\n"
"            local sub = nil\n"
"\n"
"            if not (sub_info.data == nil) then\n"
"                sub = \"memory://\"..sub_info.data\n"
"            elseif not (sub_info.url == nil) and\n"
"                url_is_safe(sub_info.url) then\n"
"                sub = sub_info.url\n"
"            end\n"
"\n"
"            if not (sub == nil) then\n"
"                mp.commandv(\"sub-add\", sub,\n"
"                    \"auto\", sub_info.ext, lang)\n"
"            else\n"
"                msg.verbose(\"No subtitle data/url for [\"..lang..\"]\")\n"
"            end\n"
"        end\n"
"    end\n"
"\n"
"    -- add chapters\n"
"    if json.chapters then\n"
"        msg.debug(\"Adding pre-parsed chapters\")\n"
"        for i = 1, #json.chapters do\n"
"            local chapter = json.chapters[i]\n"
"            local title = chapter.title or \"\"\n"
"            if title == \"\" then\n"
"                title = string.format('Chapter %02d', i)\n"
"            end\n"
"            table.insert(chapter_list, {time=chapter.start_time, title=title})\n"
"        end\n"
"    elseif not (json.description == nil) and not (json.duration == nil) then\n"
"        chapter_list = extract_chapters(json.description, json.duration)\n"
"    end\n"
"\n"
"    -- set start time\n"
"    if not (json.start_time == nil) and\n"
"        not option_was_set(\"start\") and\n"
"        not option_was_set_locally(\"start\") then\n"
"        msg.debug(\"Setting start to: \" .. json.start_time .. \" secs\")\n"
"        mp.set_property(\"file-local-options/start\", json.start_time)\n"
"    end\n"
"\n"
"    -- set aspect ratio for anamorphic video\n"
"    if not (json.stretched_ratio == nil) and\n"
"        not option_was_set(\"video-aspect\") then\n"
"        mp.set_property('file-local-options/video-aspect', json.stretched_ratio)\n"
"    end\n"
"\n"
"    local stream_opts = mp.get_property_native(\"file-local-options/stream-lavf-o\", {})\n"
"\n"
"    -- for rtmp\n"
"    if (json.protocol == \"rtmp\") then\n"
"        stream_opts = append_libav_opt(stream_opts,\n"
"            \"rtmp_tcurl\", streamurl)\n"
"        stream_opts = append_libav_opt(stream_opts,\n"
"            \"rtmp_pageurl\", json.page_url)\n"
"        stream_opts = append_libav_opt(stream_opts,\n"
"            \"rtmp_playpath\", json.play_path)\n"
"        stream_opts = append_libav_opt(stream_opts,\n"
"            \"rtmp_swfverify\", json.player_url)\n"
"        stream_opts = append_libav_opt(stream_opts,\n"
"            \"rtmp_swfurl\", json.player_url)\n"
"        stream_opts = append_libav_opt(stream_opts,\n"
"            \"rtmp_app\", json.app)\n"
"    end\n"
"\n"
"    if json.proxy and json.proxy ~= \"\" then\n"
"        stream_opts = append_libav_opt(stream_opts,\n"
"            \"http_proxy\", json.proxy)\n"
"    end\n"
"\n"
"    mp.set_property_native(\"file-local-options/stream-lavf-o\", stream_opts)\n"
"end\n"
"\n"
"mp.add_hook(o.try_ytdl_first and \"on_load\" or \"on_load_fail\", 10, function ()\n"
"    local url = mp.get_property(\"stream-open-filename\", \"\")\n"
"    if not (url:find(\"ytdl://\") == 1) and\n"
"        not ((url:find(\"https?://\") == 1) and not is_blacklisted(url)) then\n"
"        return\n"
"    end\n"
"    local start_time = os.clock()\n"
"\n"
"    -- check for youtube-dl in mpv's config dir\n"
"    if not (ytdl.searched) then\n"
"        local exesuf = (package.config:sub(1,1) == '\\\\') and '.exe' or ''\n"
"        local ytdl_mcd = mp.find_config_file(\"youtube-dl\" .. exesuf)\n"
"        if not (ytdl_mcd == nil) then\n"
"            msg.verbose(\"found youtube-dl at: \" .. ytdl_mcd)\n"
"            ytdl.path = ytdl_mcd\n"
"        end\n"
"        ytdl.searched = true\n"
"    end\n"
"\n"
"    -- strip ytdl://\n"
"    if (url:find(\"ytdl://\") == 1) then\n"
"        url = url:sub(8)\n"
"    end\n"
"\n"
"    local format = mp.get_property(\"options/ytdl-format\")\n"
"    local raw_options = mp.get_property_native(\"options/ytdl-raw-options\")\n"
"    local allsubs = true\n"
"    local proxy = nil\n"
"    local use_playlist = false\n"
"\n"
"    local command = {\n"
"        ytdl.path, \"--no-warnings\", \"-J\", \"--flat-playlist\",\n"
"        \"--sub-format\", \"ass/srt/best\"\n"
"    }\n"
"\n"
"    -- Checks if video option is \"no\", change format accordingly,\n"
"    -- but only if user didn't explicitly set one\n"
"    if (mp.get_property(\"options/vid\") == \"no\")\n"
"        and not option_was_set(\"ytdl-format\") then\n"
"\n"
"        format = \"bestaudio/best\"\n"
"        msg.verbose(\"Video disabled. Only using audio\")\n"
"    end\n"
"\n"
"    if (format == \"\") then\n"
"        format = \"bestvideo+bestaudio/best\"\n"
"    end\n"
"    table.insert(command, \"--format\")\n"
"    table.insert(command, format)\n"
"\n"
"    for param, arg in pairs(raw_options) do\n"
"        table.insert(command, \"--\" .. param)\n"
"        if (arg ~= \"\") then\n"
"            table.insert(command, arg)\n"
"        end\n"
"        if (param == \"sub-lang\") and (arg ~= \"\") then\n"
"            allsubs = false\n"
"        elseif (param == \"proxy\") and (arg ~= \"\") then\n"
"            proxy = arg\n"
"        elseif (param == \"yes-playlist\") then\n"
"            use_playlist = true\n"
"        end\n"
"    end\n"
"\n"
"    if (allsubs == true) then\n"
"        table.insert(command, \"--all-subs\")\n"
"    end\n"
"    if not use_playlist then\n"
"        table.insert(command, \"--no-playlist\")\n"
"    end\n"
"    table.insert(command, \"--\")\n"
"    table.insert(command, url)\n"
"    msg.debug(\"Running: \" .. table.concat(command,' '))\n"
"    local es, json, result = exec(command)\n"
"\n"
"    if (es < 0) or (json == nil) or (json == \"\") then\n"
"        local err = \"youtube-dl failed: \"\n"
"        if result.error and result.error == \"init\" then\n"
"            err = err .. \"not found or not enough permissions\"\n"
"        elseif not result.killed_by_us then\n"
"            err = err .. \"unexpected error ocurred\"\n"
"        else\n"
"            err = string.format(\"%s returned '%d'\", err, es)\n"
"        end\n"
"        msg.error(err)\n"
"        return\n"
"    end\n"
"\n"
"    local json, err = utils.parse_json(json)\n"
"\n"
"    if (json == nil) then\n"
"        msg.error(\"failed to parse JSON data: \" .. err)\n"
"        return\n"
"    end\n"
"\n"
"    msg.verbose(\"youtube-dl succeeded!\")\n"
"    msg.debug('ytdl parsing took '..os.clock()-start_time..' seconds')\n"
"\n"
"    json[\"proxy\"] = json[\"proxy\"] or proxy\n"
"\n"
"    -- what did we get?\n"
"    if json[\"direct\"] then\n"
"        -- direct URL, nothing to do\n"
"        msg.verbose(\"Got direct URL\")\n"
"        return\n"
"    elseif (json[\"_type\"] == \"playlist\")\n"
"        or (json[\"_type\"] == \"multi_video\") then\n"
"        -- a playlist\n"
"\n"
"        if (#json.entries == 0) then\n"
"            msg.warn(\"Got empty playlist, nothing to play.\")\n"
"            return\n"
"        end\n"
"\n"
"        local self_redirecting_url =\n"
"            json.entries[1][\"_type\"] ~= \"url_transparent\" and\n"
"            json.entries[1][\"webpage_url\"] and\n"
"            json.entries[1][\"webpage_url\"] == json[\"webpage_url\"]\n"
"\n"
"\n"
"        -- some funky guessing to detect multi-arc videos\n"
"        if self_redirecting_url and #json.entries > 1\n"
"            and json.entries[1].protocol == \"m3u8_native\"\n"
"            and json.entries[1].url then\n"
"            msg.verbose(\"multi-arc video detected, building EDL\")\n"
"\n"
"            local playlist = edl_track_joined(json.entries)\n"
"\n"
"            msg.debug(\"EDL: \" .. playlist)\n"
"\n"
"            if not playlist then\n"
"                return\n"
"            end\n"
"\n"
"            -- can't change the http headers for each entry, so use the 1st\n"
"            set_http_headers(json.entries[1].http_headers)\n"
"\n"
"            mp.set_property(\"stream-open-filename\", playlist)\n"
"            if not (json.title == nil) then\n"
"                mp.set_property(\"file-local-options/force-media-title\",\n"
"                    json.title)\n"
"            end\n"
"\n"
"            -- there might not be subs for the first segment\n"
"            local entry_wsubs = nil\n"
"            for i, entry in pairs(json.entries) do\n"
"                if not (entry.requested_subtitles == nil) then\n"
"                    entry_wsubs = i\n"
"                    break\n"
"                end\n"
"            end\n"
"\n"
"            if not (entry_wsubs == nil) and\n"
"                not (json.entries[entry_wsubs].duration == nil) then\n"
"                for j, req in pairs(json.entries[entry_wsubs].requested_subtitles) do\n"
"                    local subfile = \"edl://\"\n"
"                    for i, entry in pairs(json.entries) do\n"
"                        if not (entry.requested_subtitles == nil) and\n"
"                            not (entry.requested_subtitles[j] == nil) and\n"
"                            url_is_safe(entry.requested_subtitles[j].url) then\n"
"                            subfile = subfile..edl_escape(entry.requested_subtitles[j].url)\n"
"                        else\n"
"                            subfile = subfile..edl_escape(\"memory://WEBVTT\")\n"
"                        end\n"
"                        subfile = subfile..\",length=\"..entry.duration..\";\"\n"
"                    end\n"
"                    msg.debug(j..\" sub EDL: \"..subfile)\n"
"                    mp.commandv(\"sub-add\", subfile, \"auto\", req.ext, j)\n"
"                end\n"
"            end\n"
"\n"
"        elseif self_redirecting_url and #json.entries == 1 then\n"
"            msg.verbose(\"Playlist with single entry detected.\")\n"
"            add_single_video(json.entries[1])\n"
"        else\n"
"            local playlist_index = parse_yt_playlist(url, json)\n"
"            local playlist = {\"#EXTM3U\"}\n"
"            for i, entry in pairs(json.entries) do\n"
"                local site = entry.url\n"
"                local title = entry.title\n"
"\n"
"                if not (title == nil) then\n"
"                    title = string.gsub(title, '%s+', ' ')\n"
"                    table.insert(playlist, \"#EXTINF:0,\" .. title)\n"
"                end\n"
"\n"
"                --[[ some extractors will still return the full info for\n"
"                     all clips in the playlist and the URL will point\n"
"                     directly to the file in that case, which we don't\n"
"                     want so get the webpage URL instead, which is what\n"
"                     we want, but only if we aren't going to trigger an\n"
"                     infinite loop\n"
"                --]]\n"
"                if entry[\"webpage_url\"] and not self_redirecting_url then\n"
"                    site = entry[\"webpage_url\"]\n"
"                end\n"
"\n"
"                -- links without protocol as returned by --flat-playlist\n"
"                if not site:find(\"://\") then\n"
"                    -- youtube extractor provides only IDs,\n"
"                    -- others come prefixed with the extractor name and \":\"\n"
"                    local prefix = site:find(\":\") and \"ytdl://\" or\n"
"                        \"https://youtu.be/\"\n"
"                    table.insert(playlist, prefix .. site)\n"
"                elseif url_is_safe(site) then\n"
"                    table.insert(playlist, site)\n"
"                end\n"
"\n"
"            end\n"
"\n"
"            if use_playlist and\n"
"                not option_was_set(\"playlist-start\") and playlist_index then\n"
"                mp.set_property_number(\"playlist-start\", playlist_index)\n"
"            end\n"
"\n"
"            mp.set_property(\"stream-open-filename\", \"memory://\" .. table.concat(playlist, \"\\n\"))\n"
"        end\n"
"\n"
"    else -- probably a video\n"
"        add_single_video(json)\n"
"    end\n"
"    msg.debug('script running time: '..os.clock()-start_time..' seconds')\n"
"end)\n"
"\n"
"\n"
"mp.add_hook(\"on_preloaded\", 10, function ()\n"
"    if next(chapter_list) ~= nil then\n"
"        msg.verbose(\"Setting chapters\")\n"
"\n"
"        mp.set_property_native(\"chapter-list\", chapter_list)\n"
"        chapter_list = {}\n"
"    end\n"
"end)\n"
