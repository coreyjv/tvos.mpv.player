// Generated from player/lua/osc.lua

"local assdraw = require 'mp.assdraw'\n"
"local msg = require 'mp.msg'\n"
"local opt = require 'mp.options'\n"
"local utils = require 'mp.utils'\n"
"\n"
"--\n"
"-- Parameters\n"
"--\n"
"\n"
"-- default user option values\n"
"-- do not touch, change them in osc.conf\n"
"local user_opts = {\n"
"    showwindowed = true,        -- show OSC when windowed?\n"
"    showfullscreen = true,      -- show OSC when fullscreen?\n"
"    scalewindowed = 1,          -- scaling of the controller when windowed\n"
"    scalefullscreen = 1,        -- scaling of the controller when fullscreen\n"
"    scaleforcedwindow = 2,      -- scaling when rendered on a forced window\n"
"    vidscale = true,            -- scale the controller with the video?\n"
"    valign = 0.8,               -- vertical alignment, -1 (top) to 1 (bottom)\n"
"    halign = 0,                 -- horizontal alignment, -1 (left) to 1 (right)\n"
"    barmargin = 0,              -- vertical margin of top/bottombar\n"
"    boxalpha = 80,              -- alpha of the background box,\n"
"                                -- 0 (opaque) to 255 (fully transparent)\n"
"    hidetimeout = 500,          -- duration in ms until the OSC hides if no\n"
"                                -- mouse movement. enforced non-negative for the\n"
"                                -- user, but internally negative is \"always-on\".\n"
"    fadeduration = 200,         -- duration of fade out in ms, 0 = no fade\n"
"    deadzonesize = 0.5,         -- size of deadzone\n"
"    minmousemove = 0,           -- minimum amount of pixels the mouse has to\n"
"                                -- move between ticks to make the OSC show up\n"
"    iamaprogrammer = false,     -- use native mpv values and disable OSC\n"
"                                -- internal track list management (and some\n"
"                                -- functions that depend on it)\n"
"    layout = \"bottombar\",\n"
"    seekbarstyle = \"bar\",       -- slider (diamond marker), knob (circle\n"
"                                -- marker with guide), or bar (fill)\n"
"    seekbarkeyframes = true,    -- use keyframes when dragging the seekbar\n"
"    title = \"\044{media-title}\",   -- string compatible with property-expansion\n"
"                                -- to be shown as OSC title\n"
"    tooltipborder = 1,          -- border of tooltip in bottom/topbar\n"
"    timetotal = false,          -- display total time instead of remaining time?\n"
"    timems = false,             -- display timecodes with milliseconds?\n"
"    seekranges = true,          -- display seek ranges?\n"
"    visibility = \"auto\",        -- only used at init to set visibility_mode(...)\n"
"    boxmaxchars = 80,           -- title crop threshold for box layout\n"
"}\n"
"\n"
"-- read_options may modify hidetimeout, so save the original default value in\n"
"-- case the user set hidetimeout < 0 and we need the default instead.\n"
"local hidetimeout_def = user_opts.hidetimeout\n"
"-- read options from config and command-line\n"
"opt.read_options(user_opts, \"osc\")\n"
"if user_opts.hidetimeout < 0 then\n"
"    user_opts.hidetimeout = hidetimeout_def\n"
"    msg.warn(\"hidetimeout cannot be negative. Using \" .. user_opts.hidetimeout)\n"
"end\n"
"\n"
"local osc_param = { -- calculated by osc_init()\n"
"    playresy = 0,                           -- canvas size Y\n"
"    playresx = 0,                           -- canvas size X\n"
"    display_aspect = 1,\n"
"    unscaled_y = 0,\n"
"    areas = {},\n"
"}\n"
"\n"
"local osc_styles = {\n"
"    bigButtons = \"{\\\\blur0\\\\bord0\\\\1c&HFFFFFF\\\\3c&HFFFFFF\\\\fs50\\\\fnmpv-osd-symbols}\",\n"
"    smallButtonsL = \"{\\\\blur0\\\\bord0\\\\1c&HFFFFFF\\\\3c&HFFFFFF\\\\fs19\\\\fnmpv-osd-symbols}\",\n"
"    smallButtonsLlabel = \"{\\\\fscx105\\\\fscy105\\\\fn\" .. mp.get_property(\"options/osd-font\") .. \"}\",\n"
"    smallButtonsR = \"{\\\\blur0\\\\bord0\\\\1c&HFFFFFF\\\\3c&HFFFFFF\\\\fs30\\\\fnmpv-osd-symbols}\",\n"
"    topButtons = \"{\\\\blur0\\\\bord0\\\\1c&HFFFFFF\\\\3c&HFFFFFF\\\\fs12\\\\fnmpv-osd-symbols}\",\n"
"\n"
"    elementDown = \"{\\\\1c&H999999}\",\n"
"    timecodes = \"{\\\\blur0\\\\bord0\\\\1c&HFFFFFF\\\\3c&HFFFFFF\\\\fs20}\",\n"
"    vidtitle = \"{\\\\blur0\\\\bord0\\\\1c&HFFFFFF\\\\3c&HFFFFFF\\\\fs12\\\\q2}\",\n"
"    box = \"{\\\\rDefault\\\\blur0\\\\bord1\\\\1c&H000000\\\\3c&HFFFFFF}\",\n"
"\n"
"    topButtonsBar = \"{\\\\blur0\\\\bord0\\\\1c&HFFFFFF\\\\3c&HFFFFFF\\\\fs18\\\\fnmpv-osd-symbols}\",\n"
"    smallButtonsBar = \"{\\\\blur0\\\\bord0\\\\1c&HFFFFFF\\\\3c&HFFFFFF\\\\fs28\\\\fnmpv-osd-symbols}\",\n"
"    timecodesBar = \"{\\\\blur0\\\\bord0\\\\1c&HFFFFFF\\\\3c&HFFFFFF\\\\fs27}\",\n"
"    timePosBar = \"{\\\\blur0\\\\bord\".. user_opts.tooltipborder ..\"\\\\1c&HFFFFFF\\\\3c&H000000\\\\fs30}\",\n"
"    vidtitleBar = \"{\\\\blur0\\\\bord0\\\\1c&HFFFFFF\\\\3c&HFFFFFF\\\\fs18\\\\q2}\",\n"
"}\n"
"\n"
"-- internal states, do not touch\n"
"local state = {\n"
"    showtime,                               -- time of last invocation (last mouse move)\n"
"    osc_visible = false,\n"
"    anistart,                               -- time when the animation started\n"
"    anitype,                                -- current type of animation\n"
"    animation,                              -- current animation alpha\n"
"    mouse_down_counter = 0,                 -- used for softrepeat\n"
"    active_element = nil,                   -- nil = none, 0 = background, 1+ = see elements[]\n"
"    active_event_source = nil,              -- the \"button\" that issued the current event\n"
"    rightTC_trem = not user_opts.timetotal, -- if the right timecode should display total or remaining time\n"
"    tc_ms = user_opts.timems,               -- Should the timecodes display their time with milliseconds\n"
"    mp_screen_sizeX, mp_screen_sizeY,       -- last screen-resolution, to detect resolution changes to issue reINITs\n"
"    initREQ = false,                        -- is a re-init request pending?\n"
"    last_mouseX, last_mouseY,               -- last mouse position, to detect significant mouse movement\n"
"    message_text,\n"
"    message_timeout,\n"
"    fullscreen = false,\n"
"    timer = nil,\n"
"    cache_idle = false,\n"
"    idle = false,\n"
"    enabled = true,\n"
"    input_enabled = true,\n"
"    showhide_enabled = false,\n"
"    dmx_cache = 0,\n"
"}\n"
"\n"
"\n"
"\n"
"\n"
"--\n"
"-- Helperfunctions\n"
"--\n"
"\n"
"-- scale factor for translating between real and virtual ASS coordinates\n"
"function get_virt_scale_factor()\n"
"    local w, h = mp.get_osd_size()\n"
"    if w <= 0 or h <= 0 then\n"
"        return 0, 0\n"
"    end\n"
"    return osc_param.playresx / w, osc_param.playresy / h\n"
"end\n"
"\n"
"-- return mouse position in virtual ASS coordinates (playresx/y)\n"
"function get_virt_mouse_pos()\n"
"    local sx, sy = get_virt_scale_factor()\n"
"    local x, y = mp.get_mouse_pos()\n"
"    return x * sx, y * sy\n"
"end\n"
"\n"
"function set_virt_mouse_area(x0, y0, x1, y1, name)\n"
"    local sx, sy = get_virt_scale_factor()\n"
"    mp.set_mouse_area(x0 / sx, y0 / sy, x1 / sx, y1 / sy, name)\n"
"end\n"
"\n"
"function scale_value(x0, x1, y0, y1, val)\n"
"    local m = (y1 - y0) / (x1 - x0)\n"
"    local b = y0 - (m * x0)\n"
"    return (m * val) + b\n"
"end\n"
"\n"
"-- returns hitbox spanning coordinates (top left, bottom right corner)\n"
"-- according to alignment\n"
"function get_hitbox_coords(x, y, an, w, h)\n"
"\n"
"    local alignments = {\n"
"      [1] = function () return x, y-h, x+w, y end,\n"
"      [2] = function () return x-(w/2), y-h, x+(w/2), y end,\n"
"      [3] = function () return x-w, y-h, x, y end,\n"
"\n"
"      [4] = function () return x, y-(h/2), x+w, y+(h/2) end,\n"
"      [5] = function () return x-(w/2), y-(h/2), x+(w/2), y+(h/2) end,\n"
"      [6] = function () return x-w, y-(h/2), x, y+(h/2) end,\n"
"\n"
"      [7] = function () return x, y, x+w, y+h end,\n"
"      [8] = function () return x-(w/2), y, x+(w/2), y+h end,\n"
"      [9] = function () return x-w, y, x, y+h end,\n"
"    }\n"
"\n"
"    return alignments[an]()\n"
"end\n"
"\n"
"function get_hitbox_coords_geo(geometry)\n"
"    return get_hitbox_coords(geometry.x, geometry.y, geometry.an,\n"
"        geometry.w, geometry.h)\n"
"end\n"
"\n"
"function get_element_hitbox(element)\n"
"    return element.hitbox.x1, element.hitbox.y1,\n"
"        element.hitbox.x2, element.hitbox.y2\n"
"end\n"
"\n"
"function mouse_hit(element)\n"
"    return mouse_hit_coords(get_element_hitbox(element))\n"
"end\n"
"\n"
"function mouse_hit_coords(bX1, bY1, bX2, bY2)\n"
"    local mX, mY = get_virt_mouse_pos()\n"
"    return (mX >= bX1 and mX <= bX2 and mY >= bY1 and mY <= bY2)\n"
"end\n"
"\n"
"function limit_range(min, max, val)\n"
"    if val > max then\n"
"        val = max\n"
"    elseif val < min then\n"
"        val = min\n"
"    end\n"
"    return val\n"
"end\n"
"\n"
"-- translate value into element coordinates\n"
"function get_slider_ele_pos_for(element, val)\n"
"\n"
"    local ele_pos = scale_value(\n"
"        element.slider.min.value, element.slider.max.value,\n"
"        element.slider.min.ele_pos, element.slider.max.ele_pos,\n"
"        val)\n"
"\n"
"    return limit_range(\n"
"        element.slider.min.ele_pos, element.slider.max.ele_pos,\n"
"        ele_pos)\n"
"end\n"
"\n"
"-- translates global (mouse) coordinates to value\n"
"function get_slider_value_at(element, glob_pos)\n"
"\n"
"    local val = scale_value(\n"
"        element.slider.min.glob_pos, element.slider.max.glob_pos,\n"
"        element.slider.min.value, element.slider.max.value,\n"
"        glob_pos)\n"
"\n"
"    return limit_range(\n"
"        element.slider.min.value, element.slider.max.value,\n"
"        val)\n"
"end\n"
"\n"
"-- get value at current mouse position\n"
"function get_slider_value(element)\n"
"    return get_slider_value_at(element, get_virt_mouse_pos())\n"
"end\n"
"\n"
"function countone(val)\n"
"    if not (user_opts.iamaprogrammer) then\n"
"        val = val + 1\n"
"    end\n"
"    return val\n"
"end\n"
"\n"
"-- align:  -1 .. +1\n"
"-- frame:  size of the containing area\n"
"-- obj:    size of the object that should be positioned inside the area\n"
"-- margin: min. distance from object to frame (as long as -1 <= align <= +1)\n"
"function get_align(align, frame, obj, margin)\n"
"    return (frame / 2) + (((frame / 2) - margin - (obj / 2)) * align)\n"
"end\n"
"\n"
"-- multiplies two alpha values, formular can probably be improved\n"
"function mult_alpha(alphaA, alphaB)\n"
"    return 255 - (((1-(alphaA/255)) * (1-(alphaB/255))) * 255)\n"
"end\n"
"\n"
"function add_area(name, x1, y1, x2, y2)\n"
"    -- create area if needed\n"
"    if (osc_param.areas[name] == nil) then\n"
"        osc_param.areas[name] = {}\n"
"    end\n"
"    table.insert(osc_param.areas[name], {x1=x1, y1=y1, x2=x2, y2=y2})\n"
"end\n"
"\n"
"\n"
"--\n"
"-- Tracklist Management\n"
"--\n"
"\n"
"local nicetypes = {video = \"Video\", audio = \"Audio\", sub = \"Subtitle\"}\n"
"\n"
"-- updates the OSC internal playlists, should be run each time the track-layout changes\n"
"function update_tracklist()\n"
"    local tracktable = mp.get_property_native(\"track-list\", {})\n"
"\n"
"    -- by osc_id\n"
"    tracks_osc = {}\n"
"    tracks_osc.video, tracks_osc.audio, tracks_osc.sub = {}, {}, {}\n"
"    -- by mpv_id\n"
"    tracks_mpv = {}\n"
"    tracks_mpv.video, tracks_mpv.audio, tracks_mpv.sub = {}, {}, {}\n"
"    for n = 1, #tracktable do\n"
"        if not (tracktable[n].type == \"unknown\") then\n"
"            local type = tracktable[n].type\n"
"            local mpv_id = tonumber(tracktable[n].id)\n"
"\n"
"            -- by osc_id\n"
"            table.insert(tracks_osc[type], tracktable[n])\n"
"\n"
"            -- by mpv_id\n"
"            tracks_mpv[type][mpv_id] = tracktable[n]\n"
"            tracks_mpv[type][mpv_id].osc_id = #tracks_osc[type]\n"
"        end\n"
"    end\n"
"end\n"
"\n"
"-- return a nice list of tracks of the given type (video, audio, sub)\n"
"function get_tracklist(type)\n"
"    local msg = \"Available \" .. nicetypes[type] .. \" Tracks: \"\n"
"    if #tracks_osc[type] == 0 then\n"
"        msg = msg .. \"none\"\n"
"    else\n"
"        for n = 1, #tracks_osc[type] do\n"
"            local track = tracks_osc[type][n]\n"
"            local lang, title, selected = \"unknown\", \"\", \"\342\227\213\"\n"
"            if not(track.lang == nil) then lang = track.lang end\n"
"            if not(track.title == nil) then title = track.title end\n"
"            if (track.id == tonumber(mp.get_property(type))) then\n"
"                selected = \"\342\227\217\"\n"
"            end\n"
"            msg = msg..\"\\n\"..selected..\" \"..n..\": [\"..lang..\"] \"..title\n"
"        end\n"
"    end\n"
"    return msg\n"
"end\n"
"\n"
"-- relatively change the track of given <type> by <next> tracks\n"
"    --(+1 -> next, -1 -> previous)\n"
"function set_track(type, next)\n"
"    local current_track_mpv, current_track_osc\n"
"    if (mp.get_property(type) == \"no\") then\n"
"        current_track_osc = 0\n"
"    else\n"
"        current_track_mpv = tonumber(mp.get_property(type))\n"
"        current_track_osc = tracks_mpv[type][current_track_mpv].osc_id\n"
"    end\n"
"    local new_track_osc = (current_track_osc + next) % (#tracks_osc[type] + 1)\n"
"    local new_track_mpv\n"
"    if new_track_osc == 0 then\n"
"        new_track_mpv = \"no\"\n"
"    else\n"
"        new_track_mpv = tracks_osc[type][new_track_osc].id\n"
"    end\n"
"\n"
"    mp.commandv(\"set\", type, new_track_mpv)\n"
"\n"
"        if (new_track_osc == 0) then\n"
"        show_message(nicetypes[type] .. \" Track: none\")\n"
"    else\n"
"        show_message(nicetypes[type]  .. \" Track: \"\n"
"            .. new_track_osc .. \"/\" .. #tracks_osc[type]\n"
"            .. \" [\".. (tracks_osc[type][new_track_osc].lang or \"unknown\") ..\"] \"\n"
"            .. (tracks_osc[type][new_track_osc].title or \"\"))\n"
"    end\n"
"end\n"
"\n"
"-- get the currently selected track of <type>, OSC-style counted\n"
"function get_track(type)\n"
"    local track = mp.get_property(type)\n"
"    if track ~= \"no\" and track ~= nil then\n"
"        local tr = tracks_mpv[type][tonumber(track)]\n"
"        if tr then\n"
"            return tr.osc_id\n"
"        end\n"
"    end\n"
"    return 0\n"
"end\n"
"\n"
"\n"
"--\n"
"-- Element Management\n"
"--\n"
"\n"
"local elements = {}\n"
"\n"
"function prepare_elements()\n"
"\n"
"    -- remove elements without layout or invisble\n"
"    local elements2 = {}\n"
"    for n, element in pairs(elements) do\n"
"        if not (element.layout == nil) and (element.visible) then\n"
"            table.insert(elements2, element)\n"
"        end\n"
"    end\n"
"    elements = elements2\n"
"\n"
"    function elem_compare (a, b)\n"
"        return a.layout.layer < b.layout.layer\n"
"    end\n"
"\n"
"    table.sort(elements, elem_compare)\n"
"\n"
"\n"
"    for _,element in pairs(elements) do\n"
"\n"
"        local elem_geo = element.layout.geometry\n"
"\n"
"        -- Calculate the hitbox\n"
"        local bX1, bY1, bX2, bY2 = get_hitbox_coords_geo(elem_geo)\n"
"        element.hitbox = {x1 = bX1, y1 = bY1, x2 = bX2, y2 = bY2}\n"
"\n"
"        local style_ass = assdraw.ass_new()\n"
"\n"
"        -- prepare static elements\n"
"        style_ass:append(\"{}\") -- hack to troll new_event into inserting a \\n\n"
"        style_ass:new_event()\n"
"        style_ass:pos(elem_geo.x, elem_geo.y)\n"
"        style_ass:an(elem_geo.an)\n"
"        style_ass:append(element.layout.style)\n"
"\n"
"        element.style_ass = style_ass\n"
"\n"
"        local static_ass = assdraw.ass_new()\n"
"\n"
"\n"
"        if (element.type == \"box\") then\n"
"            --draw box\n"
"            static_ass:draw_start()\n"
"            static_ass:round_rect_cw(0, 0, elem_geo.w, elem_geo.h,\n"
"                element.layout.box.radius)\n"
"            static_ass:draw_stop()\n"
"\n"
"\n"
"        elseif (element.type == \"slider\") then\n"
"            --draw static slider parts\n"
"\n"
"            local slider_lo = element.layout.slider\n"
"            -- offset between element outline and drag-area\n"
"            local foV = slider_lo.border + slider_lo.gap\n"
"\n"
"            -- calculate positions of min and max points\n"
"            if (slider_lo.stype == \"slider\") or\n"
"                (slider_lo.stype == \"knob\") then\n"
"                element.slider.min.ele_pos = elem_geo.h / 2\n"
"                element.slider.max.ele_pos = elem_geo.w - (elem_geo.h / 2)\n"
"\n"
"            elseif (slider_lo.stype == \"bar\") then\n"
"                element.slider.min.ele_pos =\n"
"                    slider_lo.border + slider_lo.gap\n"
"                element.slider.max.ele_pos =\n"
"                    elem_geo.w - (slider_lo.border + slider_lo.gap)\n"
"            end\n"
"\n"
"            element.slider.min.glob_pos =\n"
"                element.hitbox.x1 + element.slider.min.ele_pos\n"
"            element.slider.max.glob_pos =\n"
"                element.hitbox.x1 + element.slider.max.ele_pos\n"
"\n"
"            -- -- --\n"
"\n"
"            static_ass:draw_start()\n"
"\n"
"            -- the box\n"
"            static_ass:rect_cw(0, 0, elem_geo.w, elem_geo.h);\n"
"\n"
"            -- the \"hole\"\n"
"            static_ass:rect_ccw(slider_lo.border, slider_lo.border,\n"
"                elem_geo.w - slider_lo.border, elem_geo.h - slider_lo.border)\n"
"\n"
"            -- marker nibbles\n"
"            if not (element.slider.markerF == nil) and (slider_lo.gap > 0) then\n"
"                local markers = element.slider.markerF()\n"
"                for _,marker in pairs(markers) do\n"
"                    if (marker > element.slider.min.value) and\n"
"                        (marker < element.slider.max.value) then\n"
"\n"
"                        local s = get_slider_ele_pos_for(element, marker)\n"
"\n"
"                        if (slider_lo.gap > 1) then -- draw triangles\n"
"\n"
"                            local a = slider_lo.gap / 0.5 --0.866\n"
"\n"
"                            --top\n"
"                            if (slider_lo.nibbles_top) then\n"
"                                static_ass:move_to(s - (a/2), slider_lo.border)\n"
"                                static_ass:line_to(s + (a/2), slider_lo.border)\n"
"                                static_ass:line_to(s, foV)\n"
"                            end\n"
"\n"
"                            --bottom\n"
"                            if (slider_lo.nibbles_bottom) then\n"
"                                static_ass:move_to(s - (a/2),\n"
"                                    elem_geo.h - slider_lo.border)\n"
"                                static_ass:line_to(s,\n"
"                                    elem_geo.h - foV)\n"
"                                static_ass:line_to(s + (a/2),\n"
"                                    elem_geo.h - slider_lo.border)\n"
"                            end\n"
"\n"
"                        else -- draw 2x1px nibbles\n"
"\n"
"                            --top\n"
"                            if (slider_lo.nibbles_top) then\n"
"                                static_ass:rect_cw(s - 1, slider_lo.border,\n"
"                                    s + 1, slider_lo.border + slider_lo.gap);\n"
"                            end\n"
"\n"
"                            --bottom\n"
"                            if (slider_lo.nibbles_bottom) then\n"
"                                static_ass:rect_cw(s - 1,\n"
"                                    elem_geo.h -slider_lo.border -slider_lo.gap,\n"
"                                    s + 1, elem_geo.h - slider_lo.border);\n"
"                            end\n"
"                        end\n"
"                    end\n"
"                end\n"
"            end\n"
"        end\n"
"\n"
"        element.static_ass = static_ass\n"
"\n"
"\n"
"        -- if the element is supposed to be disabled,\n"
"        -- style it accordingly and kill the eventresponders\n"
"        if not (element.enabled) then\n"
"            element.layout.alpha[1] = 136\n"
"            element.eventresponder = nil\n"
"        end\n"
"    end\n"
"end\n"
"\n"
"\n"
"--\n"
"-- Element Rendering\n"
"--\n"
"\n"
"function render_elements(master_ass)\n"
"\n"
"    for n=1, #elements do\n"
"        local element = elements[n]\n"
"\n"
"        local style_ass = assdraw.ass_new()\n"
"        style_ass:merge(element.style_ass)\n"
"\n"
"        --alpha\n"
"        local ar = element.layout.alpha\n"
"        if not (state.animation == nil) then\n"
"            ar = {}\n"
"            for ai, av in pairs(element.layout.alpha) do\n"
"                ar[ai] = mult_alpha(av, state.animation)\n"
"            end\n"
"        end\n"
"\n"
"        style_ass:append(string.format(\"{\\\\1a&H%X&\\\\2a&H%X&\\\\3a&H%X&\\\\4a&H%X&}\",\n"
"            ar[1], ar[2], ar[3], ar[4]))\n"
"\n"
"        if element.eventresponder and (state.active_element == n) then\n"
"\n"
"            -- run render event functions\n"
"            if not (element.eventresponder.render == nil) then\n"
"                element.eventresponder.render(element)\n"
"            end\n"
"\n"
"            if mouse_hit(element) then\n"
"                -- mouse down styling\n"
"                if (element.styledown) then\n"
"                    style_ass:append(osc_styles.elementDown)\n"
"                end\n"
"\n"
"                if (element.softrepeat) and (state.mouse_down_counter >= 15\n"
"                    and state.mouse_down_counter % 5 == 0) then\n"
"\n"
"                    element.eventresponder[state.active_event_source..\"_down\"](element)\n"
"                end\n"
"                state.mouse_down_counter = state.mouse_down_counter + 1\n"
"            end\n"
"\n"
"        end\n"
"\n"
"        local elem_ass = assdraw.ass_new()\n"
"\n"
"        elem_ass:merge(style_ass)\n"
"\n"
"        if not (element.type == \"button\") then\n"
"            elem_ass:merge(element.static_ass)\n"
"        end\n"
"\n"
"        if (element.type == \"slider\") then\n"
"\n"
"            local slider_lo = element.layout.slider\n"
"            local elem_geo = element.layout.geometry\n"
"            local s_min = element.slider.min.value\n"
"            local s_max = element.slider.max.value\n"
"\n"
"            -- draw pos marker\n"
"            local pos = element.slider.posF()\n"
"\n"
"            if not (pos == nil) then\n"
"\n"
"                local foV = slider_lo.border + slider_lo.gap\n"
"                local foH = 0\n"
"                if (slider_lo.stype == \"slider\") or\n"
"                    (slider_lo.stype == \"knob\") then\n"
"                    foH = elem_geo.h / 2\n"
"                elseif (slider_lo.stype == \"bar\") then\n"
"                    foH = slider_lo.border + slider_lo.gap\n"
"                end\n"
"\n"
"                local xp = get_slider_ele_pos_for(element, pos)\n"
"\n"
"                -- the filling\n"
"                local innerH = elem_geo.h - (2*foV)\n"
"\n"
"                if (slider_lo.stype == \"bar\") then\n"
"                    elem_ass:rect_cw(foH, foV, xp, elem_geo.h - foV)\n"
"                elseif (slider_lo.stype == \"slider\") then\n"
"                    elem_ass:move_to(xp, foV)\n"
"                    elem_ass:line_to(xp+(innerH/2), (innerH/2)+foV)\n"
"                    elem_ass:line_to(xp, (innerH)+foV)\n"
"                    elem_ass:line_to(xp-(innerH/2), (innerH/2)+foV)\n"
"                elseif (slider_lo.stype == \"knob\") then\n"
"                    elem_ass:rect_cw(xp, (9*innerH/20) + foV,\n"
"                        elem_geo.w - foH, (11*innerH/20) + foV)\n"
"                    elem_ass:rect_cw(foH, (3*innerH/8) + foV,\n"
"                        xp, (5*innerH/8) + foV)\n"
"                    elem_ass:round_rect_cw(xp - innerH/2, foV,\n"
"                        xp + innerH/2, foV + innerH, innerH/2.0)\n"
"                end\n"
"            end\n"
"\n"
"            -- seek ranges\n"
"            local seekRanges = element.slider.seekRangesF()\n"
"            if not (seekRanges == nil) then\n"
"                for _,range in pairs(seekRanges) do\n"
"                    local pstart = get_slider_ele_pos_for(element, range[\"start\"])\n"
"                    local pend = get_slider_ele_pos_for(element, range[\"end\"])\n"
"                    elem_ass:rect_ccw(pstart, (elem_geo.h/2)-1, pend, (elem_geo.h/2) + 1)\n"
"                end\n"
"            end\n"
"\n"
"            elem_ass:draw_stop()\n"
"\n"
"            -- add tooltip\n"
"            if not (element.slider.tooltipF == nil) then\n"
"\n"
"                if mouse_hit(element) then\n"
"                    local sliderpos = get_slider_value(element)\n"
"                    local tooltiplabel = element.slider.tooltipF(sliderpos)\n"
"\n"
"                    local an = slider_lo.tooltip_an\n"
"\n"
"                    local ty\n"
"\n"
"                    if (an == 2) then\n"
"                        ty = element.hitbox.y1 - slider_lo.border\n"
"                    else\n"
"                        ty = element.hitbox.y1 + elem_geo.h/2\n"
"                    end\n"
"\n"
"                    local tx = get_virt_mouse_pos()\n"
"                    if (slider_lo.adjust_tooltip) then\n"
"                        if (an == 2) then\n"
"                            if (sliderpos < (s_min + 3)) then\n"
"                                an = an - 1\n"
"                            elseif (sliderpos > (s_max - 3)) then\n"
"                                an = an + 1\n"
"                            end\n"
"                        elseif (sliderpos > (s_max-s_min)/2) then\n"
"                            an = an + 1\n"
"                            tx = tx - 5\n"
"                        else\n"
"                            an = an - 1\n"
"                            tx = tx + 10\n"
"                        end\n"
"                    end\n"
"\n"
"                    -- tooltip label\n"
"                    elem_ass:new_event()\n"
"                    elem_ass:pos(tx, ty)\n"
"                    elem_ass:an(an)\n"
"                    elem_ass:append(slider_lo.tooltip_style)\n"
"\n"
"                    --alpha\n"
"                    local ar = slider_lo.alpha\n"
"                    if not (state.animation == nil) then\n"
"                        ar = {}\n"
"                        for ai, av in pairs(slider_lo.alpha) do\n"
"                            ar[ai] = mult_alpha(av, state.animation)\n"
"                        end\n"
"                    end\n"
"                    elem_ass:append(string.format(\"{\\\\1a&H%X&\\\\2a&H%X&\\\\3a&H%X&\\\\4a&H%X&}\",\n"
"                        ar[1], ar[2], ar[3], ar[4]))\n"
"\n"
"                    elem_ass:append(tooltiplabel)\n"
"\n"
"                end\n"
"            end\n"
"\n"
"        elseif (element.type == \"button\") then\n"
"\n"
"            local buttontext\n"
"            if type(element.content) == \"function\" then\n"
"                buttontext = element.content() -- function objects\n"
"            elseif not (element.content == nil) then\n"
"                buttontext = element.content -- text objects\n"
"            end\n"
"\n"
"            local maxchars = element.layout.button.maxchars\n"
"            if not (maxchars == nil) and (#buttontext > maxchars) then\n"
"                local max_ratio = 1.25  -- up to 25% more chars while shrinking\n"
"                local limit = math.max(0, math.floor(maxchars * max_ratio) - 3)\n"
"                if (#buttontext > limit) then\n"
"                    while (#buttontext > limit) do\n"
"                        buttontext = buttontext:gsub(\".[\\128-\\191]*\044\", \"\")\n"
"                    end\n"
"                    buttontext = buttontext .. \"...\"\n"
"                end\n"
"                local _, nchars2 = buttontext:gsub(\".[\\128-\\191]*\", \"\")\n"
"                local stretch = (maxchars/#buttontext)*100\n"
"                buttontext = string.format(\"{\\\\fscx%f}\",\n"
"                    (maxchars/#buttontext)*100) .. buttontext\n"
"            end\n"
"\n"
"            elem_ass:append(buttontext)\n"
"        end\n"
"\n"
"        master_ass:merge(elem_ass)\n"
"    end\n"
"end\n"
"\n"
"--\n"
"-- Message display\n"
"--\n"
"\n"
"-- pos is 1 based\n"
"function limited_list(prop, pos)\n"
"    local proplist = mp.get_property_native(prop, {})\n"
"    local count = #proplist\n"
"    if count == 0 then\n"
"        return count, proplist\n"
"    end\n"
"\n"
"    local fs = tonumber(mp.get_property('options/osd-font-size'))\n"
"    local max = math.ceil(osc_param.unscaled_y*0.75 / fs)\n"
"    if max % 2 == 0 then\n"
"        max = max - 1\n"
"    end\n"
"    local delta = math.ceil(max / 2) - 1\n"
"    local begi = math.max(math.min(pos - delta, count - max + 1), 1)\n"
"    local endi = math.min(begi + max - 1, count)\n"
"\n"
"    local reslist = {}\n"
"    for i=begi, endi do\n"
"        local item = proplist[i]\n"
"        item.current = (i == pos) and true or nil\n"
"        table.insert(reslist, item)\n"
"    end\n"
"    return count, reslist\n"
"end\n"
"\n"
"function get_playlist()\n"
"    local pos = mp.get_property_number('playlist-pos', 0) + 1\n"
"    local count, limlist = limited_list('playlist', pos)\n"
"    if count == 0 then\n"
"        return 'Empty playlist.'\n"
"    end\n"
"\n"
"    local message = string.format('Playlist [%d/%d]:\\n', pos, count)\n"
"    for i, v in ipairs(limlist) do\n"
"        local title = v.title\n"
"        local _, filename = utils.split_path(v.filename)\n"
"        if title == nil then\n"
"            title = filename\n"
"        end\n"
"        message = string.format('%s %s %s\\n', message,\n"
"            (v.current and '\342\227\217' or '\342\227\213'), title)\n"
"    end\n"
"    return message\n"
"end\n"
"\n"
"function get_chapterlist()\n"
"    local pos = mp.get_property_number('chapter', 0) + 1\n"
"    local count, limlist = limited_list('chapter-list', pos)\n"
"    if count == 0 then\n"
"        return 'No chapters.'\n"
"    end\n"
"\n"
"    local message = string.format('Chapters [%d/%d]:\\n', pos, count)\n"
"    for i, v in ipairs(limlist) do\n"
"        local time = mp.format_time(v.time)\n"
"        local title = v.title\n"
"        if title == nil then\n"
"            title = string.format('Chapter %02d', i)\n"
"        end\n"
"        message = string.format('%s[%s] %s %s\\n', message, time,\n"
"            (v.current and '\342\227\217' or '\342\227\213'), title)\n"
"    end\n"
"    return message\n"
"end\n"
"\n"
"function show_message(text, duration)\n"
"\n"
"    --print(\"text: \"..text..\"   duration: \" .. duration)\n"
"    if duration == nil then\n"
"        duration = tonumber(mp.get_property(\"options/osd-duration\")) / 1000\n"
"    elseif not type(duration) == \"number\" then\n"
"        print(\"duration: \" .. duration)\n"
"    end\n"
"\n"
"    -- cut the text short, otherwise the following functions\n"
"    -- may slow down massively on huge input\n"
"    text = string.sub(text, 0, 4000)\n"
"\n"
"    -- replace actual linebreaks with ASS linebreaks\n"
"    text = string.gsub(text, \"\\n\", \"\\\\N\")\n"
"\n"
"    state.message_text = text\n"
"    state.message_timeout = mp.get_time() + duration\n"
"end\n"
"\n"
"function render_message(ass)\n"
"    if not(state.message_timeout == nil) and not(state.message_text == nil)\n"
"        and state.message_timeout > mp.get_time() then\n"
"        local _, lines = string.gsub(state.message_text, \"\\\\N\", \"\")\n"
"\n"
"        local fontsize = tonumber(mp.get_property(\"options/osd-font-size\"))\n"
"        local outline = tonumber(mp.get_property(\"options/osd-border-size\"))\n"
"        local maxlines = math.ceil(osc_param.unscaled_y*0.75 / fontsize)\n"
"        local counterscale = osc_param.playresy / osc_param.unscaled_y\n"
"\n"
"        fontsize = fontsize * counterscale / math.max(0.65 + math.min(lines/maxlines, 1), 1)\n"
"        outline = outline * counterscale / math.max(0.75 + math.min(lines/maxlines, 1)/2, 1)\n"
"\n"
"        local style = \"{\\\\bord\" .. outline .. \"\\\\fs\" .. fontsize .. \"}\"\n"
"\n"
"\n"
"        ass:new_event()\n"
"        ass:append(style .. state.message_text)\n"
"    else\n"
"        state.message_text = nil\n"
"        state.message_timeout = nil\n"
"    end\n"
"end\n"
"\n"
"--\n"
"-- Initialisation and Layout\n"
"--\n"
"\n"
"function new_element(name, type)\n"
"    elements[name] = {}\n"
"    elements[name].type = type\n"
"\n"
"    -- add default stuff\n"
"    elements[name].eventresponder = {}\n"
"    elements[name].visible = true\n"
"    elements[name].enabled = true\n"
"    elements[name].softrepeat = false\n"
"    elements[name].styledown = (type == \"button\")\n"
"    elements[name].state = {}\n"
"\n"
"    if (type == \"slider\") then\n"
"        elements[name].slider = {min = {value = 0}, max = {value = 100}}\n"
"    end\n"
"\n"
"\n"
"    return elements[name]\n"
"end\n"
"\n"
"function add_layout(name)\n"
"    if not (elements[name] == nil) then\n"
"        -- new layout\n"
"        elements[name].layout = {}\n"
"\n"
"        -- set layout defaults\n"
"        elements[name].layout.layer = 50\n"
"        elements[name].layout.alpha = {[1] = 0, [2] = 255, [3] = 255, [4] = 255}\n"
"\n"
"        if (elements[name].type == \"button\") then\n"
"            elements[name].layout.button = {\n"
"                maxchars = nil,\n"
"            }\n"
"        elseif (elements[name].type == \"slider\") then\n"
"            -- slider defaults\n"
"            elements[name].layout.slider = {\n"
"                border = 1,\n"
"                gap = 1,\n"
"                nibbles_top = true,\n"
"                nibbles_bottom = true,\n"
"                stype = \"slider\",\n"
"                adjust_tooltip = true,\n"
"                tooltip_style = \"\",\n"
"                tooltip_an = 2,\n"
"                alpha = {[1] = 0, [2] = 255, [3] = 88, [4] = 255},\n"
"            }\n"
"        elseif (elements[name].type == \"box\") then\n"
"            elements[name].layout.box = {radius = 0}\n"
"        end\n"
"\n"
"        return elements[name].layout\n"
"    else\n"
"        msg.error(\"Can't add_layout to element \\\"\"..name..\"\\\", doesn't exist.\")\n"
"    end\n"
"end\n"
"\n"
"--\n"
"-- Layouts\n"
"--\n"
"\n"
"local layouts = {}\n"
"\n"
"-- Classic box layout\n"
"layouts[\"box\"] = function ()\n"
"\n"
"    local osc_geo = {\n"
"        w = 550,    -- width\n"
"        h = 138,    -- height\n"
"        r = 10,     -- corner-radius\n"
"        p = 15,     -- padding\n"
"    }\n"
"\n"
"    -- make sure the OSC actually fits into the video\n"
"    if (osc_param.playresx < (osc_geo.w + (2 * osc_geo.p))) then\n"
"        osc_param.playresy = (osc_geo.w+(2*osc_geo.p))/osc_param.display_aspect\n"
"        osc_param.playresx = osc_param.playresy * osc_param.display_aspect\n"
"    end\n"
"\n"
"    -- position of the controller according to video aspect and valignment\n"
"    local posX = math.floor(get_align(user_opts.halign, osc_param.playresx,\n"
"        osc_geo.w, 0))\n"
"    local posY = math.floor(get_align(user_opts.valign, osc_param.playresy,\n"
"        osc_geo.h, 0))\n"
"\n"
"    -- position offset for contents aligned at the borders of the box\n"
"    local pos_offsetX = (osc_geo.w - (2*osc_geo.p)) / 2\n"
"    local pos_offsetY = (osc_geo.h - (2*osc_geo.p)) / 2\n"
"\n"
"    osc_param.areas = {} -- delete areas\n"
"\n"
"    -- area for active mouse input\n"
"    add_area(\"input\", get_hitbox_coords(posX, posY, 5, osc_geo.w, osc_geo.h))\n"
"\n"
"    -- area for show/hide\n"
"    local sh_area_y0, sh_area_y1\n"
"    if user_opts.valign > 0 then\n"
"        -- deadzone above OSC\n"
"        sh_area_y0 = get_align(-1 + (2*user_opts.deadzonesize),\n"
"            posY - (osc_geo.h / 2), 0, 0)\n"
"        sh_area_y1 = osc_param.playresy\n"
"    else\n"
"        -- deadzone below OSC\n"
"        sh_area_y0 = 0\n"
"        sh_area_y1 = (posY + (osc_geo.h / 2)) +\n"
"            get_align(1 - (2*user_opts.deadzonesize),\n"
"            osc_param.playresy - (posY + (osc_geo.h / 2)), 0, 0)\n"
"    end\n"
"    add_area(\"showhide\", 0, sh_area_y0, osc_param.playresx, sh_area_y1)\n"
"\n"
"    -- fetch values\n"
"    local osc_w, osc_h, osc_r, osc_p =\n"
"        osc_geo.w, osc_geo.h, osc_geo.r, osc_geo.p\n"
"\n"
"    local lo\n"
"\n"
"    --\n"
"    -- Background box\n"
"    --\n"
"\n"
"    new_element(\"bgbox\", \"box\")\n"
"    lo = add_layout(\"bgbox\")\n"
"\n"
"    lo.geometry = {x = posX, y = posY, an = 5, w = osc_w, h = osc_h}\n"
"    lo.layer = 10\n"
"    lo.style = osc_styles.box\n"
"    lo.alpha[1] = user_opts.boxalpha\n"
"    lo.alpha[3] = user_opts.boxalpha\n"
"    lo.box.radius = osc_r\n"
"\n"
"    --\n"
"    -- Title row\n"
"    --\n"
"\n"
"    local titlerowY = posY - pos_offsetY - 10\n"
"\n"
"    lo = add_layout(\"title\")\n"
"    lo.geometry = {x = posX, y = titlerowY, an = 8, w = 496, h = 12}\n"
"    lo.style = osc_styles.vidtitle\n"
"    lo.button.maxchars = user_opts.boxmaxchars\n"
"\n"
"    lo = add_layout(\"pl_prev\")\n"
"    lo.geometry =\n"
"        {x = (posX - pos_offsetX), y = titlerowY, an = 7, w = 12, h = 12}\n"
"    lo.style = osc_styles.topButtons\n"
"\n"
"    lo = add_layout(\"pl_next\")\n"
"    lo.geometry =\n"
"        {x = (posX + pos_offsetX), y = titlerowY, an = 9, w = 12, h = 12}\n"
"    lo.style = osc_styles.topButtons\n"
"\n"
"    --\n"
"    -- Big buttons\n"
"    --\n"
"\n"
"    local bigbtnrowY = posY - pos_offsetY + 35\n"
"    local bigbtndist = 60\n"
"\n"
"    lo = add_layout(\"playpause\")\n"
"    lo.geometry =\n"
"        {x = posX, y = bigbtnrowY, an = 5, w = 40, h = 40}\n"
"    lo.style = osc_styles.bigButtons\n"
"\n"
"    lo = add_layout(\"skipback\")\n"
"    lo.geometry =\n"
"        {x = posX - bigbtndist, y = bigbtnrowY, an = 5, w = 40, h = 40}\n"
"    lo.style = osc_styles.bigButtons\n"
"\n"
"    lo = add_layout(\"skipfrwd\")\n"
"    lo.geometry =\n"
"        {x = posX + bigbtndist, y = bigbtnrowY, an = 5, w = 40, h = 40}\n"
"    lo.style = osc_styles.bigButtons\n"
"\n"
"    lo = add_layout(\"ch_prev\")\n"
"    lo.geometry =\n"
"        {x = posX - (bigbtndist * 2), y = bigbtnrowY, an = 5, w = 40, h = 40}\n"
"    lo.style = osc_styles.bigButtons\n"
"\n"
"    lo = add_layout(\"ch_next\")\n"
"    lo.geometry =\n"
"        {x = posX + (bigbtndist * 2), y = bigbtnrowY, an = 5, w = 40, h = 40}\n"
"    lo.style = osc_styles.bigButtons\n"
"\n"
"    lo = add_layout(\"cy_audio\")\n"
"    lo.geometry =\n"
"        {x = posX - pos_offsetX, y = bigbtnrowY, an = 1, w = 70, h = 18}\n"
"    lo.style = osc_styles.smallButtonsL\n"
"\n"
"    lo = add_layout(\"cy_sub\")\n"
"    lo.geometry =\n"
"        {x = posX - pos_offsetX, y = bigbtnrowY, an = 7, w = 70, h = 18}\n"
"    lo.style = osc_styles.smallButtonsL\n"
"\n"
"    lo = add_layout(\"tog_fs\")\n"
"    lo.geometry =\n"
"        {x = posX+pos_offsetX - 25, y = bigbtnrowY, an = 4, w = 25, h = 25}\n"
"    lo.style = osc_styles.smallButtonsR\n"
"\n"
"    lo = add_layout(\"volume\")\n"
"    lo.geometry =\n"
"        {x = posX+pos_offsetX - (25 * 2) - osc_geo.p,\n"
"         y = bigbtnrowY, an = 4, w = 25, h = 25}\n"
"    lo.style = osc_styles.smallButtonsR\n"
"\n"
"    --\n"
"    -- Seekbar\n"
"    --\n"
"\n"
"    lo = add_layout(\"seekbar\")\n"
"    lo.geometry =\n"
"        {x = posX, y = posY+pos_offsetY-22, an = 2, w = pos_offsetX*2, h = 15}\n"
"    lo.style = osc_styles.timecodes\n"
"    lo.slider.tooltip_style = osc_styles.vidtitle\n"
"    lo.slider.stype = user_opts[\"seekbarstyle\"]\n"
"    if lo.slider.stype == \"knob\" then\n"
"        lo.slider.border = 0\n"
"    end\n"
"\n"
"    --\n"
"    -- Timecodes + Cache\n"
"    --\n"
"\n"
"    local bottomrowY = posY + pos_offsetY - 5\n"
"\n"
"    lo = add_layout(\"tc_left\")\n"
"    lo.geometry =\n"
"        {x = posX - pos_offsetX, y = bottomrowY, an = 4, w = 110, h = 18}\n"
"    lo.style = osc_styles.timecodes\n"
"\n"
"    lo = add_layout(\"tc_right\")\n"
"    lo.geometry =\n"
"        {x = posX + pos_offsetX, y = bottomrowY, an = 6, w = 110, h = 18}\n"
"    lo.style = osc_styles.timecodes\n"
"\n"
"    lo = add_layout(\"cache\")\n"
"    lo.geometry =\n"
"        {x = posX, y = bottomrowY, an = 5, w = 110, h = 18}\n"
"    lo.style = osc_styles.timecodes\n"
"\n"
"end\n"
"\n"
"-- slim box layout\n"
"layouts[\"slimbox\"] = function ()\n"
"\n"
"    local osc_geo = {\n"
"        w = 660,    -- width\n"
"        h = 70,     -- height\n"
"        r = 10,     -- corner-radius\n"
"    }\n"
"\n"
"    -- make sure the OSC actually fits into the video\n"
"    if (osc_param.playresx < (osc_geo.w)) then\n"
"        osc_param.playresy = (osc_geo.w)/osc_param.display_aspect\n"
"        osc_param.playresx = osc_param.playresy * osc_param.display_aspect\n"
"    end\n"
"\n"
"    -- position of the controller according to video aspect and valignment\n"
"    local posX = math.floor(get_align(user_opts.halign, osc_param.playresx,\n"
"        osc_geo.w, 0))\n"
"    local posY = math.floor(get_align(user_opts.valign, osc_param.playresy,\n"
"        osc_geo.h, 0))\n"
"\n"
"    osc_param.areas = {} -- delete areas\n"
"\n"
"    -- area for active mouse input\n"
"    add_area(\"input\", get_hitbox_coords(posX, posY, 5, osc_geo.w, osc_geo.h))\n"
"\n"
"    -- area for show/hide\n"
"    local sh_area_y0, sh_area_y1\n"
"    if user_opts.valign > 0 then\n"
"        -- deadzone above OSC\n"
"        sh_area_y0 = get_align(-1 + (2*user_opts.deadzonesize),\n"
"            posY - (osc_geo.h / 2), 0, 0)\n"
"        sh_area_y1 = osc_param.playresy\n"
"    else\n"
"        -- deadzone below OSC\n"
"        sh_area_y0 = 0\n"
"        sh_area_y1 = (posY + (osc_geo.h / 2)) +\n"
"            get_align(1 - (2*user_opts.deadzonesize),\n"
"            osc_param.playresy - (posY + (osc_geo.h / 2)), 0, 0)\n"
"    end\n"
"    add_area(\"showhide\", 0, sh_area_y0, osc_param.playresx, sh_area_y1)\n"
"\n"
"    local lo\n"
"\n"
"    local tc_w, ele_h, inner_w = 100, 20, osc_geo.w - 100\n"
"\n"
"    -- styles\n"
"    local styles = {\n"
"        box = \"{\\\\rDefault\\\\blur0\\\\bord1\\\\1c&H000000\\\\3c&HFFFFFF}\",\n"
"        timecodes = \"{\\\\1c&HFFFFFF\\\\3c&H000000\\\\fs20\\\\bord2\\\\blur1}\",\n"
"        tooltip = \"{\\\\1c&HFFFFFF\\\\3c&H000000\\\\fs12\\\\bord1\\\\blur0.5}\",\n"
"    }\n"
"\n"
"\n"
"    new_element(\"bgbox\", \"box\")\n"
"    lo = add_layout(\"bgbox\")\n"
"\n"
"    lo.geometry = {x = posX, y = posY - 1, an = 2, w = inner_w, h = ele_h}\n"
"    lo.layer = 10\n"
"    lo.style = osc_styles.box\n"
"    lo.alpha[1] = user_opts.boxalpha\n"
"    lo.alpha[3] = 0\n"
"    if not (user_opts[\"seekbarstyle\"] == \"bar\") then\n"
"        lo.box.radius = osc_geo.r\n"
"    end\n"
"\n"
"\n"
"    lo = add_layout(\"seekbar\")\n"
"    lo.geometry =\n"
"        {x = posX, y = posY - 1, an = 2, w = inner_w, h = ele_h}\n"
"    lo.style = osc_styles.timecodes\n"
"    lo.slider.border = 0\n"
"    lo.slider.gap = 1.5\n"
"    lo.slider.tooltip_style = styles.tooltip\n"
"    lo.slider.stype = user_opts[\"seekbarstyle\"]\n"
"    lo.slider.adjust_tooltip = false\n"
"\n"
"    --\n"
"    -- Timecodes\n"
"    --\n"
"\n"
"    lo = add_layout(\"tc_left\")\n"
"    lo.geometry =\n"
"        {x = posX - (inner_w/2) + osc_geo.r, y = posY + 1,\n"
"        an = 7, w = tc_w, h = ele_h}\n"
"    lo.style = styles.timecodes\n"
"    lo.alpha[3] = user_opts.boxalpha\n"
"\n"
"    lo = add_layout(\"tc_right\")\n"
"    lo.geometry =\n"
"        {x = posX + (inner_w/2) - osc_geo.r, y = posY + 1,\n"
"        an = 9, w = tc_w, h = ele_h}\n"
"    lo.style = styles.timecodes\n"
"    lo.alpha[3] = user_opts.boxalpha\n"
"\n"
"    -- Cache\n"
"\n"
"    lo = add_layout(\"cache\")\n"
"    lo.geometry =\n"
"        {x = posX, y = posY + 1,\n"
"        an = 8, w = tc_w, h = ele_h}\n"
"    lo.style = styles.timecodes\n"
"    lo.alpha[3] = user_opts.boxalpha\n"
"\n"
"\n"
"end\n"
"\n"
"layouts[\"bottombar\"] = function()\n"
"    local osc_geo = {\n"
"        x = -2,\n"
"        y = osc_param.playresy - 54 - user_opts.barmargin,\n"
"        an = 7,\n"
"        w = osc_param.playresx + 4,\n"
"        h = 56,\n"
"    }\n"
"\n"
"    local padX = 9\n"
"    local padY = 3\n"
"    local buttonW = 27\n"
"    local tcW = (state.tc_ms) and 170 or 110\n"
"    local tsW = 90\n"
"    local minW = (buttonW + padX)*5 + (tcW + padX)*4 + (tsW + padX)*2\n"
"\n"
"    if ((osc_param.display_aspect > 0) and (osc_param.playresx < minW)) then\n"
"        osc_param.playresy = minW / osc_param.display_aspect\n"
"        osc_param.playresx = osc_param.playresy * osc_param.display_aspect\n"
"        osc_geo.y = osc_param.playresy - 54 - user_opts.barmargin\n"
"        osc_geo.w = osc_param.playresx + 4\n"
"    end\n"
"\n"
"    local line1 = osc_geo.y + 9 + padY\n"
"    local line2 = osc_geo.y + 36 + padY\n"
"\n"
"    osc_param.areas = {}\n"
"\n"
"    add_area(\"input\", get_hitbox_coords(osc_geo.x, osc_geo.y, osc_geo.an,\n"
"                                        osc_geo.w, osc_geo.h))\n"
"\n"
"    local sh_area_y0, sh_area_y1\n"
"    sh_area_y0 = get_align(-1 + (2*user_opts.deadzonesize),\n"
"                           osc_geo.y - (osc_geo.h / 2), 0, 0)\n"
"    sh_area_y1 = osc_param.playresy - user_opts.barmargin\n"
"    add_area(\"showhide\", 0, sh_area_y0, osc_param.playresx, sh_area_y1)\n"
"\n"
"    local lo, geo\n"
"\n"
"    -- Background bar\n"
"    new_element(\"bgbox\", \"box\")\n"
"    lo = add_layout(\"bgbox\")\n"
"\n"
"    lo.geometry = osc_geo\n"
"    lo.layer = 10\n"
"    lo.style = osc_styles.box\n"
"    lo.alpha[1] = user_opts.boxalpha\n"
"\n"
"\n"
"    -- Playlist prev/next\n"
"    geo = { x = osc_geo.x + padX, y = line1,\n"
"            an = 4, w = 18, h = 18 - padY }\n"
"    lo = add_layout(\"pl_prev\")\n"
"    lo.geometry = geo\n"
"    lo.style = osc_styles.topButtonsBar\n"
"\n"
"    geo = { x = geo.x + geo.w + padX, y = geo.y, an = geo.an, w = geo.w, h = geo.h }\n"
"    lo = add_layout(\"pl_next\")\n"
"    lo.geometry = geo\n"
"    lo.style = osc_styles.topButtonsBar\n"
"\n"
"    local t_l = geo.x + geo.w + padX\n"
"\n"
"    -- Cache\n"
"    geo = { x = osc_geo.x + osc_geo.w - padX, y = geo.y,\n"
"            an = 6, w = 150, h = geo.h }\n"
"    lo = add_layout(\"cache\")\n"
"    lo.geometry = geo\n"
"    lo.style = osc_styles.vidtitleBar\n"
"\n"
"    local t_r = geo.x - geo.w - padX*2\n"
"\n"
"    -- Title\n"
"    geo = { x = t_l, y = geo.y, an = 4,\n"
"            w = t_r - t_l, h = geo.h }\n"
"    lo = add_layout(\"title\")\n"
"    lo.geometry = geo\n"
"    lo.style = string.format(\"%s{\\\\clip(%f,%f,%f,%f)}\",\n"
"        osc_styles.vidtitleBar,\n"
"        geo.x, geo.y-geo.h, geo.w, geo.y+geo.h)\n"
"\n"
"\n"
"    -- Playback control buttons\n"
"    geo = { x = osc_geo.x + padX, y = line2, an = 4,\n"
"            w = buttonW, h = 36 - padY*2}\n"
"    lo = add_layout(\"playpause\")\n"
"    lo.geometry = geo\n"
"    lo.style = osc_styles.smallButtonsBar\n"
"\n"
"    geo = { x = geo.x + geo.w + padX, y = geo.y, an = geo.an, w = geo.w, h = geo.h }\n"
"    lo = add_layout(\"ch_prev\")\n"
"    lo.geometry = geo\n"
"    lo.style = osc_styles.smallButtonsBar\n"
"\n"
"    geo = { x = geo.x + geo.w + padX, y = geo.y, an = geo.an, w = geo.w, h = geo.h }\n"
"    lo = add_layout(\"ch_next\")\n"
"    lo.geometry = geo\n"
"    lo.style = osc_styles.smallButtonsBar\n"
"\n"
"    -- Left timecode\n"
"    geo = { x = geo.x + geo.w + padX + tcW, y = geo.y, an = 6,\n"
"            w = tcW, h = geo.h }\n"
"    lo = add_layout(\"tc_left\")\n"
"    lo.geometry = geo\n"
"    lo.style = osc_styles.timecodesBar\n"
"\n"
"    local sb_l = geo.x + padX\n"
"\n"
"    -- Fullscreen button\n"
"    geo = { x = osc_geo.x + osc_geo.w - buttonW - padX, y = geo.y, an = 4,\n"
"            w = buttonW, h = geo.h }\n"
"    lo = add_layout(\"tog_fs\")\n"
"    lo.geometry = geo\n"
"    lo.style = osc_styles.smallButtonsBar\n"
"\n"
"    -- Volume\n"
"    geo = { x = geo.x - geo.w - padX, y = geo.y, an = geo.an, w = geo.w, h = geo.h }\n"
"    lo = add_layout(\"volume\")\n"
"    lo.geometry = geo\n"
"    lo.style = osc_styles.smallButtonsBar\n"
"\n"
"    -- Track selection buttons\n"
"    geo = { x = geo.x - tsW - padX, y = geo.y, an = geo.an, w = tsW, h = geo.h }\n"
"    lo = add_layout(\"cy_sub\")\n"
"    lo.geometry = geo\n"
"    lo.style = osc_styles.smallButtonsBar\n"
"\n"
"    geo = { x = geo.x - geo.w - padX, y = geo.y, an = geo.an, w = geo.w, h = geo.h }\n"
"    lo = add_layout(\"cy_audio\")\n"
"    lo.geometry = geo\n"
"    lo.style = osc_styles.smallButtonsBar\n"
"\n"
"\n"
"    -- Right timecode\n"
"    geo = { x = geo.x - padX - tcW - 10, y = geo.y, an = geo.an,\n"
"            w = tcW, h = geo.h }\n"
"    lo = add_layout(\"tc_right\")\n"
"    lo.geometry = geo\n"
"    lo.style = osc_styles.timecodesBar\n"
"\n"
"    local sb_r = geo.x - padX\n"
"\n"
"\n"
"    -- Seekbar\n"
"    geo = { x = sb_l, y = geo.y, an = geo.an,\n"
"            w = math.max(0, sb_r - sb_l), h = geo.h }\n"
"    new_element(\"bgbar1\", \"box\")\n"
"    lo = add_layout(\"bgbar1\")\n"
"\n"
"    lo.geometry = geo\n"
"    lo.layer = 15\n"
"    lo.style = osc_styles.timecodesBar\n"
"    lo.alpha[1] =\n"
"        math.min(255, user_opts.boxalpha + (255 - user_opts.boxalpha)*0.8)\n"
"\n"
"    lo = add_layout(\"seekbar\")\n"
"    lo.geometry = geo\n"
"    lo.style = osc_styles.timecodes\n"
"    lo.slider.border = 0\n"
"    lo.slider.gap = 2\n"
"    lo.slider.tooltip_style = osc_styles.timePosBar\n"
"    lo.slider.tooltip_an = 5\n"
"    lo.slider.stype = user_opts[\"seekbarstyle\"]\n"
"end\n"
"\n"
"layouts[\"topbar\"] = function()\n"
"    local osc_geo = {\n"
"        x = -2,\n"
"        y = 54 + user_opts.barmargin,\n"
"        an = 1,\n"
"        w = osc_param.playresx + 4,\n"
"        h = 56,\n"
"    }\n"
"\n"
"    local padX = 9\n"
"    local padY = 3\n"
"    local buttonW = 27\n"
"    local tcW = (state.tc_ms) and 170 or 110\n"
"    local tsW = 90\n"
"    local minW = (buttonW + padX)*5 + (tcW + padX)*4 + (tsW + padX)*2\n"
"\n"
"    if ((osc_param.display_aspect > 0) and (osc_param.playresx < minW)) then\n"
"        osc_param.playresy = minW / osc_param.display_aspect\n"
"        osc_param.playresx = osc_param.playresy * osc_param.display_aspect\n"
"        osc_geo.y = 54 + user_opts.barmargin\n"
"        osc_geo.w = osc_param.playresx + 4\n"
"    end\n"
"\n"
"    local line1 = osc_geo.y - 36 - padY\n"
"    local line2 = osc_geo.y - 9 - padY\n"
"\n"
"    osc_param.areas = {}\n"
"\n"
"    add_area(\"input\", get_hitbox_coords(osc_geo.x, osc_geo.y, osc_geo.an,\n"
"                                        osc_geo.w, osc_geo.h))\n"
"\n"
"    local sh_area_y0, sh_area_y1\n"
"    sh_area_y0 = user_opts.barmargin\n"
"    sh_area_y1 = (osc_geo.y + (osc_geo.h / 2)) +\n"
"                 get_align(1 - (2*user_opts.deadzonesize),\n"
"                 osc_param.playresy - (osc_geo.y + (osc_geo.h / 2)), 0, 0)\n"
"    add_area(\"showhide\", 0, sh_area_y0, osc_param.playresx, sh_area_y1)\n"
"\n"
"    local lo, geo\n"
"\n"
"    -- Background bar\n"
"    new_element(\"bgbox\", \"box\")\n"
"    lo = add_layout(\"bgbox\")\n"
"\n"
"    lo.geometry = osc_geo\n"
"    lo.layer = 10\n"
"    lo.style = osc_styles.box\n"
"    lo.alpha[1] = user_opts.boxalpha\n"
"\n"
"\n"
"    -- Playback control buttons\n"
"    geo = { x = osc_geo.x + padX, y = line1, an = 4,\n"
"            w = buttonW, h = 36 - padY*2 }\n"
"    lo = add_layout(\"playpause\")\n"
"    lo.geometry = geo\n"
"    lo.style = osc_styles.smallButtonsBar\n"
"\n"
"    geo = { x = geo.x + geo.w + padX, y = geo.y, an = geo.an, w = geo.w, h = geo.h }\n"
"    lo = add_layout(\"ch_prev\")\n"
"    lo.geometry = geo\n"
"    lo.style = osc_styles.smallButtonsBar\n"
"\n"
"    geo = { x = geo.x + geo.w + padX, y = geo.y, an = geo.an, w = geo.w, h = geo.h }\n"
"    lo = add_layout(\"ch_next\")\n"
"    lo.geometry = geo\n"
"    lo.style = osc_styles.smallButtonsBar\n"
"\n"
"\n"
"    -- Left timecode\n"
"    geo = { x = geo.x + geo.w + padX + tcW, y = geo.y, an = 6,\n"
"            w = tcW, h = geo.h }\n"
"    lo = add_layout(\"tc_left\")\n"
"    lo.geometry = geo\n"
"    lo.style = osc_styles.timecodesBar\n"
"\n"
"    local sb_l = geo.x + padX\n"
"\n"
"    -- Fullscreen button\n"
"    geo = { x = osc_geo.x + osc_geo.w - buttonW - padX, y = geo.y, an = 4,\n"
"            w = buttonW, h = geo.h }\n"
"    lo = add_layout(\"tog_fs\")\n"
"    lo.geometry = geo\n"
"    lo.style = osc_styles.smallButtonsBar\n"
"\n"
"    -- Volume\n"
"    geo = { x = geo.x - geo.w - padX, y = geo.y, an = geo.an, w = geo.w, h = geo.h }\n"
"    lo = add_layout(\"volume\")\n"
"    lo.geometry = geo\n"
"    lo.style = osc_styles.smallButtonsBar\n"
"\n"
"    -- Track selection buttons\n"
"    geo = { x = geo.x - tsW - padX, y = geo.y, an = geo.an, w = tsW, h = geo.h }\n"
"    lo = add_layout(\"cy_sub\")\n"
"    lo.geometry = geo\n"
"    lo.style = osc_styles.smallButtonsBar\n"
"\n"
"    geo = { x = geo.x - geo.w - padX, y = geo.y, an = geo.an, w = geo.w, h = geo.h }\n"
"    lo = add_layout(\"cy_audio\")\n"
"    lo.geometry = geo\n"
"    lo.style = osc_styles.smallButtonsBar\n"
"\n"
"\n"
"    -- Right timecode\n"
"    geo = { x = geo.x - geo.w - padX - tcW - 10, y = geo.y, an = 4,\n"
"            w = tcW, h = geo.h }\n"
"    lo = add_layout(\"tc_right\")\n"
"    lo.geometry = geo\n"
"    lo.style = osc_styles.timecodesBar\n"
"\n"
"    local sb_r = geo.x - padX\n"
"\n"
"\n"
"    -- Seekbar\n"
"    geo = { x = sb_l, y = user_opts.barmargin, an = 7,\n"
"        w = math.max(0, sb_r - sb_l), h = geo.h }\n"
"    new_element(\"bgbar1\", \"box\")\n"
"    lo = add_layout(\"bgbar1\")\n"
"\n"
"    lo.geometry = geo\n"
"    lo.layer = 15\n"
"    lo.style = osc_styles.timecodesBar\n"
"    lo.alpha[1] =\n"
"        math.min(255, user_opts.boxalpha + (255 - user_opts.boxalpha)*0.8)\n"
"\n"
"    lo = add_layout(\"seekbar\")\n"
"    lo.geometry = geo\n"
"    lo.style = osc_styles.timecodesBar\n"
"    lo.slider.border = 0\n"
"    lo.slider.gap = 2\n"
"    lo.slider.tooltip_style = osc_styles.timePosBar\n"
"    lo.slider.stype = user_opts[\"seekbarstyle\"]\n"
"    lo.slider.tooltip_an = 5\n"
"\n"
"\n"
"    -- Playlist prev/next\n"
"    geo = { x = osc_geo.x + padX, y = line2, an = 4, w = 18, h = 18 - padY }\n"
"    lo = add_layout(\"pl_prev\")\n"
"    lo.geometry = geo\n"
"    lo.style = osc_styles.topButtonsBar\n"
"\n"
"    geo = { x = geo.x + geo.w + padX, y = geo.y, an = geo.an, w = geo.w, h = geo.h }\n"
"    lo = add_layout(\"pl_next\")\n"
"    lo.geometry = geo\n"
"    lo.style = osc_styles.topButtonsBar\n"
"\n"
"    local t_l = geo.x + geo.w + padX\n"
"\n"
"    -- Cache\n"
"    geo = { x = osc_geo.x + osc_geo.w - padX, y = geo.y,\n"
"            an = 6, w = 150, h = geo.h }\n"
"    lo = add_layout(\"cache\")\n"
"    lo.geometry = geo\n"
"    lo.style = osc_styles.vidtitleBar\n"
"\n"
"    local t_r = geo.x - geo.w - padX*2\n"
"\n"
"    -- Title\n"
"    geo = { x = t_l, y = geo.y, an = 4,\n"
"            w = t_r - t_l, h = geo.h }\n"
"    lo = add_layout(\"title\")\n"
"    lo.geometry = geo\n"
"    lo.style = string.format(\"%s{\\\\clip(%f,%f,%f,%f)}\",\n"
"        osc_styles.vidtitleBar,\n"
"        geo.x, geo.y-geo.h, geo.w, geo.y+geo.h)\n"
"end\n"
"\n"
"-- Validate string type user options\n"
"function validate_user_opts()\n"
"    if layouts[user_opts.layout] == nil then\n"
"        msg.warn(\"Invalid setting \\\"\"..user_opts.layout..\"\\\" for layout\")\n"
"        user_opts.layout = \"box\"\n"
"    end\n"
"\n"
"    if user_opts.seekbarstyle ~= \"slider\" and\n"
"       user_opts.seekbarstyle ~= \"bar\" and\n"
"       user_opts.seekbarstyle ~= \"knob\" then\n"
"        msg.warn(\"Invalid setting \\\"\" .. user_opts.seekbarstyle\n"
"            .. \"\\\" for seekbarstyle\")\n"
"        user_opts.seekbarstyle = \"slider\"\n"
"    end\n"
"end\n"
"\n"
"\n"
"-- OSC INIT\n"
"function osc_init()\n"
"    msg.debug(\"osc_init\")\n"
"\n"
"    -- set canvas resolution according to display aspect and scaling setting\n"
"    local baseResY = 720\n"
"    local display_w, display_h, display_aspect = mp.get_osd_size()\n"
"    local scale = 1\n"
"\n"
"    if (mp.get_property(\"video\") == \"no\") then -- dummy/forced window\n"
"        scale = user_opts.scaleforcedwindow\n"
"    elseif state.fullscreen then\n"
"        scale = user_opts.scalefullscreen\n"
"    else\n"
"        scale = user_opts.scalewindowed\n"
"    end\n"
"\n"
"    if user_opts.vidscale then\n"
"        osc_param.unscaled_y = baseResY\n"
"    else\n"
"        osc_param.unscaled_y = display_h\n"
"    end\n"
"    osc_param.playresy = osc_param.unscaled_y / scale\n"
"    if (display_aspect > 0) then\n"
"        osc_param.display_aspect = display_aspect\n"
"    end\n"
"    osc_param.playresx = osc_param.playresy * osc_param.display_aspect\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"    elements = {}\n"
"\n"
"    -- some often needed stuff\n"
"    local pl_count = mp.get_property_number(\"playlist-count\", 0)\n"
"    local have_pl = (pl_count > 1)\n"
"    local pl_pos = mp.get_property_number(\"playlist-pos\", 0) + 1\n"
"    local have_ch = (mp.get_property_number(\"chapters\", 0) > 0)\n"
"    local loop = mp.get_property(\"loop-playlist\", \"no\")\n"
"\n"
"    local ne\n"
"\n"
"    -- title\n"
"    ne = new_element(\"title\", \"button\")\n"
"\n"
"    ne.content = function ()\n"
"        local title = mp.command_native({\"expand-text\", user_opts.title})\n"
"        -- escape ASS, and strip newlines and trailing slashes\n"
"        title = title:gsub(\"\\\\n\", \" \"):gsub(\"\\\\\044\", \"\"):gsub(\"{\",\"\\\\{\")\n"
"        return not (title == \"\") and title or \"mpv\"\n"
"    end\n"
"\n"
"    ne.eventresponder[\"mbtn_left_up\"] = function ()\n"
"        local title = mp.get_property_osd(\"media-title\")\n"
"        if (have_pl) then\n"
"            title = string.format(\"[%d/%d] %s\", countone(pl_pos - 1),\n"
"                                  pl_count, title)\n"
"        end\n"
"        show_message(title)\n"
"    end\n"
"\n"
"    ne.eventresponder[\"mbtn_right_up\"] =\n"
"        function () show_message(mp.get_property_osd(\"filename\")) end\n"
"\n"
"    -- playlist buttons\n"
"\n"
"    -- prev\n"
"    ne = new_element(\"pl_prev\", \"button\")\n"
"\n"
"    ne.content = \"\\238\\132\\144\"\n"
"    ne.enabled = (pl_pos > 1) or (loop ~= \"no\")\n"
"    ne.eventresponder[\"mbtn_left_up\"] =\n"
"        function ()\n"
"            mp.commandv(\"playlist-prev\", \"weak\")\n"
"            show_message(get_playlist(), 3)\n"
"        end\n"
"    ne.eventresponder[\"shift+mbtn_left_up\"] =\n"
"        function () show_message(get_playlist(), 3) end\n"
"    ne.eventresponder[\"mbtn_right_up\"] =\n"
"        function () show_message(get_playlist(), 3) end\n"
"\n"
"    --next\n"
"    ne = new_element(\"pl_next\", \"button\")\n"
"\n"
"    ne.content = \"\\238\\132\\129\"\n"
"    ne.enabled = (have_pl and (pl_pos < pl_count)) or (loop ~= \"no\")\n"
"    ne.eventresponder[\"mbtn_left_up\"] =\n"
"        function ()\n"
"            mp.commandv(\"playlist-next\", \"weak\")\n"
"            show_message(get_playlist(), 3)\n"
"        end\n"
"    ne.eventresponder[\"shift+mbtn_left_up\"] =\n"
"        function () show_message(get_playlist(), 3) end\n"
"    ne.eventresponder[\"mbtn_right_up\"] =\n"
"        function () show_message(get_playlist(), 3) end\n"
"\n"
"\n"
"    -- big buttons\n"
"\n"
"    --playpause\n"
"    ne = new_element(\"playpause\", \"button\")\n"
"\n"
"    ne.content = function ()\n"
"        if mp.get_property(\"pause\") == \"yes\" then\n"
"            return (\"\\238\\132\\129\")\n"
"        else\n"
"            return (\"\\238\\128\\130\")\n"
"        end\n"
"    end\n"
"    ne.eventresponder[\"mbtn_left_up\"] =\n"
"        function () mp.commandv(\"cycle\", \"pause\") end\n"
"\n"
"    --skipback\n"
"    ne = new_element(\"skipback\", \"button\")\n"
"\n"
"    ne.softrepeat = true\n"
"    ne.content = \"\\238\\128\\132\"\n"
"    ne.eventresponder[\"mbtn_left_down\"] =\n"
"        function () mp.commandv(\"seek\", -5, \"relative\", \"keyframes\") end\n"
"    ne.eventresponder[\"shift+mbtn_left_down\"] =\n"
"        function () mp.commandv(\"frame-back-step\") end\n"
"    ne.eventresponder[\"mbtn_right_down\"] =\n"
"        function () mp.commandv(\"seek\", -30, \"relative\", \"keyframes\") end\n"
"\n"
"    --skipfrwd\n"
"    ne = new_element(\"skipfrwd\", \"button\")\n"
"\n"
"    ne.softrepeat = true\n"
"    ne.content = \"\\238\\128\\133\"\n"
"    ne.eventresponder[\"mbtn_left_down\"] =\n"
"        function () mp.commandv(\"seek\", 10, \"relative\", \"keyframes\") end\n"
"    ne.eventresponder[\"shift+mbtn_left_down\"] =\n"
"        function () mp.commandv(\"frame-step\") end\n"
"    ne.eventresponder[\"mbtn_right_down\"] =\n"
"        function () mp.commandv(\"seek\", 60, \"relative\", \"keyframes\") end\n"
"\n"
"    --ch_prev\n"
"    ne = new_element(\"ch_prev\", \"button\")\n"
"\n"
"    ne.enabled = have_ch\n"
"    ne.content = \"\\238\\132\\132\"\n"
"    ne.eventresponder[\"mbtn_left_up\"] =\n"
"        function ()\n"
"            mp.commandv(\"add\", \"chapter\", -1)\n"
"            show_message(get_chapterlist(), 3)\n"
"        end\n"
"    ne.eventresponder[\"shift+mbtn_left_up\"] =\n"
"        function () show_message(get_chapterlist(), 3) end\n"
"    ne.eventresponder[\"mbtn_right_up\"] =\n"
"        function () show_message(get_chapterlist(), 3) end\n"
"\n"
"    --ch_next\n"
"    ne = new_element(\"ch_next\", \"button\")\n"
"\n"
"    ne.enabled = have_ch\n"
"    ne.content = \"\\238\\132\\133\"\n"
"    ne.eventresponder[\"mbtn_left_up\"] =\n"
"        function ()\n"
"            mp.commandv(\"add\", \"chapter\", 1)\n"
"            show_message(get_chapterlist(), 3)\n"
"        end\n"
"    ne.eventresponder[\"shift+mbtn_left_up\"] =\n"
"        function () show_message(get_chapterlist(), 3) end\n"
"    ne.eventresponder[\"mbtn_right_up\"] =\n"
"        function () show_message(get_chapterlist(), 3) end\n"
"\n"
"    --\n"
"    update_tracklist()\n"
"\n"
"    --cy_audio\n"
"    ne = new_element(\"cy_audio\", \"button\")\n"
"\n"
"    ne.enabled = (#tracks_osc.audio > 0)\n"
"    ne.content = function ()\n"
"        local aid = \"\342\200\223\"\n"
"        if not (get_track(\"audio\") == 0) then\n"
"            aid = get_track(\"audio\")\n"
"        end\n"
"        return (\"\\238\\132\\134\" .. osc_styles.smallButtonsLlabel\n"
"            .. \" \" .. aid .. \"/\" .. #tracks_osc.audio)\n"
"    end\n"
"    ne.eventresponder[\"mbtn_left_up\"] =\n"
"        function () set_track(\"audio\", 1) end\n"
"    ne.eventresponder[\"mbtn_right_up\"] =\n"
"        function () set_track(\"audio\", -1) end\n"
"    ne.eventresponder[\"shift+mbtn_left_down\"] =\n"
"        function () show_message(get_tracklist(\"audio\"), 2) end\n"
"\n"
"    --cy_sub\n"
"    ne = new_element(\"cy_sub\", \"button\")\n"
"\n"
"    ne.enabled = (#tracks_osc.sub > 0)\n"
"    ne.content = function ()\n"
"        local sid = \"\342\200\223\"\n"
"        if not (get_track(\"sub\") == 0) then\n"
"            sid = get_track(\"sub\")\n"
"        end\n"
"        return (\"\\238\\132\\135\" .. osc_styles.smallButtonsLlabel\n"
"            .. \" \" .. sid .. \"/\" .. #tracks_osc.sub)\n"
"    end\n"
"    ne.eventresponder[\"mbtn_left_up\"] =\n"
"        function () set_track(\"sub\", 1) end\n"
"    ne.eventresponder[\"mbtn_right_up\"] =\n"
"        function () set_track(\"sub\", -1) end\n"
"    ne.eventresponder[\"shift+mbtn_left_down\"] =\n"
"        function () show_message(get_tracklist(\"sub\"), 2) end\n"
"\n"
"    --tog_fs\n"
"    ne = new_element(\"tog_fs\", \"button\")\n"
"    ne.content = function ()\n"
"        if (state.fullscreen) then\n"
"            return (\"\\238\\132\\137\")\n"
"        else\n"
"            return (\"\\238\\132\\136\")\n"
"        end\n"
"    end\n"
"    ne.eventresponder[\"mbtn_left_up\"] =\n"
"        function () mp.commandv(\"cycle\", \"fullscreen\") end\n"
"\n"
"\n"
"    --seekbar\n"
"    ne = new_element(\"seekbar\", \"slider\")\n"
"\n"
"    ne.enabled = not (mp.get_property(\"percent-pos\") == nil)\n"
"    ne.slider.markerF = function ()\n"
"        local duration = mp.get_property_number(\"duration\", nil)\n"
"        if not (duration == nil) then\n"
"            local chapters = mp.get_property_native(\"chapter-list\", {})\n"
"            local markers = {}\n"
"            for n = 1, #chapters do\n"
"                markers[n] = (chapters[n].time / duration * 100)\n"
"            end\n"
"            return markers\n"
"        else\n"
"            return {}\n"
"        end\n"
"    end\n"
"    ne.slider.posF =\n"
"        function () return mp.get_property_number(\"percent-pos\", nil) end\n"
"    ne.slider.tooltipF = function (pos)\n"
"        local duration = mp.get_property_number(\"duration\", nil)\n"
"        if not ((duration == nil) or (pos == nil)) then\n"
"            possec = duration * (pos / 100)\n"
"            return mp.format_time(possec)\n"
"        else\n"
"            return \"\"\n"
"        end\n"
"    end\n"
"    ne.slider.seekRangesF = function()\n"
"        if not (user_opts.seekranges) then\n"
"            return nil\n"
"        end\n"
"        local cache_state = mp.get_property_native(\"demuxer-cache-state\", nil)\n"
"        if not cache_state then\n"
"            return nil\n"
"        end\n"
"        local duration = mp.get_property_number(\"duration\", nil)\n"
"        if (duration == nil) or duration <= 0 then\n"
"            return nil\n"
"        end\n"
"        local ranges = cache_state[\"seekable-ranges\"]\n"
"        for _, range in pairs(ranges) do\n"
"            range[\"start\"] = 100 * range[\"start\"] / duration\n"
"            range[\"end\"] = 100 * range[\"end\"] / duration\n"
"        end\n"
"        return ranges\n"
"    end\n"
"    ne.eventresponder[\"mouse_move\"] = --keyframe seeking when mouse is dragged\n"
"        function (element)\n"
"            -- mouse move events may pile up during seeking and may still get\n"
"            -- sent when the user is done seeking, so we need to throw away\n"
"            -- identical seeks\n"
"            local seekto = get_slider_value(element)\n"
"            if (element.state.lastseek == nil) or\n"
"                (not (element.state.lastseek == seekto)) then\n"
"                    mp.commandv(\"seek\", seekto, \"absolute-percent\",\n"
"                        user_opts.seekbarkeyframes and \"keyframes\" or \"exact\")\n"
"                    element.state.lastseek = seekto\n"
"            end\n"
"\n"
"        end\n"
"    ne.eventresponder[\"mbtn_left_down\"] = --exact seeks on single clicks\n"
"        function (element) mp.commandv(\"seek\", get_slider_value(element),\n"
"            \"absolute-percent\", \"exact\") end\n"
"    ne.eventresponder[\"reset\"] =\n"
"        function (element) element.state.lastseek = nil end\n"
"\n"
"\n"
"    -- tc_left (current pos)\n"
"    ne = new_element(\"tc_left\", \"button\")\n"
"\n"
"    ne.content = function ()\n"
"        if (state.tc_ms) then\n"
"            return (mp.get_property_osd(\"playback-time/full\"))\n"
"        else\n"
"            return (mp.get_property_osd(\"playback-time\"))\n"
"        end\n"
"    end\n"
"    ne.eventresponder[\"mbtn_left_up\"] = function ()\n"
"        state.tc_ms = not state.tc_ms\n"
"        request_init()\n"
"    end\n"
"\n"
"    -- tc_right (total/remaining time)\n"
"    ne = new_element(\"tc_right\", \"button\")\n"
"\n"
"    ne.visible = (mp.get_property_number(\"duration\", 0) > 0)\n"
"    ne.content = function ()\n"
"        if (state.rightTC_trem) then\n"
"            if state.tc_ms then\n"
"                return (\"-\"..mp.get_property_osd(\"playtime-remaining/full\"))\n"
"            else\n"
"                return (\"-\"..mp.get_property_osd(\"playtime-remaining\"))\n"
"            end\n"
"        else\n"
"            if state.tc_ms then\n"
"                return (mp.get_property_osd(\"duration/full\"))\n"
"            else\n"
"                return (mp.get_property_osd(\"duration\"))\n"
"            end\n"
"        end\n"
"    end\n"
"    ne.eventresponder[\"mbtn_left_up\"] =\n"
"        function () state.rightTC_trem = not state.rightTC_trem end\n"
"\n"
"    -- cache\n"
"    ne = new_element(\"cache\", \"button\")\n"
"\n"
"    ne.content = function ()\n"
"        local cache_state = mp.get_property_native(\"demuxer-cache-state\", {})\n"
"        if not (cache_state[\"seekable-ranges\"] and\n"
"            #cache_state[\"seekable-ranges\"] > 0) then\n"
"            -- probably not a network stream\n"
"            return \"\"\n"
"        end\n"
"        local dmx_cache = mp.get_property_number(\"demuxer-cache-duration\")\n"
"        if dmx_cache and (dmx_cache > state.dmx_cache * 1.1 or\n"
"                dmx_cache < state.dmx_cache * 0.9) then\n"
"            state.dmx_cache = dmx_cache\n"
"        else\n"
"            dmx_cache = state.dmx_cache\n"
"        end\n"
"        local min = math.floor(dmx_cache / 60)\n"
"        local sec = dmx_cache % 60\n"
"        return \"Cache: \" .. (min > 0 and\n"
"            string.format(\"%sm%02.0fs\", min, sec) or\n"
"            string.format(\"%3.0fs\", dmx_cache))\n"
"    end\n"
"\n"
"    -- volume\n"
"    ne = new_element(\"volume\", \"button\")\n"
"\n"
"    ne.content = function()\n"
"        local volume = mp.get_property_number(\"volume\", 0)\n"
"        local mute = mp.get_property_native(\"mute\")\n"
"        local volicon = {\"\\238\\132\\139\", \"\\238\\132\\140\",\n"
"                         \"\\238\\132\\141\", \"\\238\\132\\142\"}\n"
"        if volume == 0 or mute then\n"
"            return \"\\238\\132\\138\"\n"
"        else\n"
"            return volicon[math.min(4,math.ceil(volume / (100/3)))]\n"
"        end\n"
"    end\n"
"    ne.eventresponder[\"mbtn_left_up\"] =\n"
"        function () mp.commandv(\"cycle\", \"mute\") end\n"
"\n"
"    ne.eventresponder[\"wheel_up_press\"] =\n"
"        function () mp.commandv(\"osd-auto\", \"add\", \"volume\", 5) end\n"
"    ne.eventresponder[\"wheel_down_press\"] =\n"
"        function () mp.commandv(\"osd-auto\", \"add\", \"volume\", -5) end\n"
"\n"
"\n"
"    -- load layout\n"
"    layouts[user_opts.layout]()\n"
"\n"
"    --do something with the elements\n"
"    prepare_elements()\n"
"\n"
"end\n"
"\n"
"\n"
"\n"
"--\n"
"-- Other important stuff\n"
"--\n"
"\n"
"\n"
"function show_osc()\n"
"    -- show when disabled can happen (e.g. mouse_move) due to async/delayed unbinding\n"
"    if not state.enabled then return end\n"
"\n"
"    msg.trace(\"show_osc\")\n"
"    --remember last time of invocation (mouse move)\n"
"    state.showtime = mp.get_time()\n"
"\n"
"    osc_visible(true)\n"
"\n"
"    if (user_opts.fadeduration > 0) then\n"
"        state.anitype = nil\n"
"    end\n"
"end\n"
"\n"
"function hide_osc()\n"
"    msg.trace(\"hide_osc\")\n"
"    if not state.enabled then\n"
"        -- typically hide happens at render() from tick(), but now tick() is\n"
"        -- no-op and won't render again to remove the osc, so do that manually.\n"
"        state.osc_visible = false\n"
"        timer_stop()\n"
"        render_wipe()\n"
"    elseif (user_opts.fadeduration > 0) then\n"
"        if not(state.osc_visible == false) then\n"
"            state.anitype = \"out\"\n"
"            control_timer()\n"
"        end\n"
"    else\n"
"        osc_visible(false)\n"
"    end\n"
"end\n"
"\n"
"function osc_visible(visible)\n"
"    state.osc_visible = visible\n"
"    control_timer()\n"
"end\n"
"\n"
"function pause_state(name, enabled)\n"
"    state.paused = enabled\n"
"    control_timer()\n"
"end\n"
"\n"
"function cache_state(name, idle)\n"
"    state.cache_idle = idle\n"
"    control_timer()\n"
"end\n"
"\n"
"function control_timer()\n"
"    if (state.paused) and (state.osc_visible) and\n"
"        ( not(state.cache_idle) or not (state.anitype == nil) ) then\n"
"\n"
"        timer_start()\n"
"    else\n"
"        timer_stop()\n"
"    end\n"
"end\n"
"\n"
"function timer_start()\n"
"    if not (state.timer_active) then\n"
"        msg.trace(\"timer start\")\n"
"\n"
"        if (state.timer == nil) then\n"
"            -- create new timer\n"
"            state.timer = mp.add_periodic_timer(0.03, tick)\n"
"        else\n"
"            -- resume existing one\n"
"            state.timer:resume()\n"
"        end\n"
"\n"
"        state.timer_active = true\n"
"    end\n"
"end\n"
"\n"
"function timer_stop()\n"
"    if (state.timer_active) then\n"
"        msg.trace(\"timer stop\")\n"
"\n"
"        if not (state.timer == nil) then\n"
"            -- kill timer\n"
"            state.timer:kill()\n"
"        end\n"
"\n"
"        state.timer_active = false\n"
"    end\n"
"end\n"
"\n"
"\n"
"\n"
"function mouse_leave()\n"
"    if user_opts.hidetimeout >= 0 then\n"
"        hide_osc()\n"
"    end\n"
"    -- reset mouse position\n"
"    state.last_mouseX, state.last_mouseY = nil, nil\n"
"end\n"
"\n"
"function request_init()\n"
"    state.initREQ = true\n"
"end\n"
"\n"
"function render_wipe()\n"
"    msg.trace(\"render_wipe()\")\n"
"    mp.set_osd_ass(0, 0, \"{}\")\n"
"end\n"
"\n"
"function render()\n"
"    msg.trace(\"rendering\")\n"
"    local current_screen_sizeX, current_screen_sizeY, aspect = mp.get_osd_size()\n"
"    local mouseX, mouseY = get_virt_mouse_pos()\n"
"    local now = mp.get_time()\n"
"\n"
"    -- check if display changed, if so request reinit\n"
"    if not (state.mp_screen_sizeX == current_screen_sizeX\n"
"        and state.mp_screen_sizeY == current_screen_sizeY) then\n"
"\n"
"        request_init()\n"
"\n"
"        state.mp_screen_sizeX = current_screen_sizeX\n"
"        state.mp_screen_sizeY = current_screen_sizeY\n"
"    end\n"
"\n"
"    -- init management\n"
"    if state.initREQ then\n"
"        osc_init()\n"
"        state.initREQ = false\n"
"\n"
"        -- store initial mouse position\n"
"        if (state.last_mouseX == nil or state.last_mouseY == nil)\n"
"            and not (mouseX == nil or mouseY == nil) then\n"
"\n"
"            state.last_mouseX, state.last_mouseY = mouseX, mouseY\n"
"        end\n"
"    end\n"
"\n"
"\n"
"    -- fade animation\n"
"    if not(state.anitype == nil) then\n"
"\n"
"        if (state.anistart == nil) then\n"
"            state.anistart = now\n"
"        end\n"
"\n"
"        if (now < state.anistart + (user_opts.fadeduration/1000)) then\n"
"\n"
"            if (state.anitype == \"in\") then --fade in\n"
"                osc_visible(true)\n"
"                state.animation = scale_value(state.anistart,\n"
"                    (state.anistart + (user_opts.fadeduration/1000)),\n"
"                    255, 0, now)\n"
"            elseif (state.anitype == \"out\") then --fade out\n"
"                state.animation = scale_value(state.anistart,\n"
"                    (state.anistart + (user_opts.fadeduration/1000)),\n"
"                    0, 255, now)\n"
"            end\n"
"\n"
"        else\n"
"            if (state.anitype == \"out\") then\n"
"                osc_visible(false)\n"
"            end\n"
"            state.anistart = nil\n"
"            state.animation = nil\n"
"            state.anitype =  nil\n"
"        end\n"
"    else\n"
"        state.anistart = nil\n"
"        state.animation = nil\n"
"        state.anitype =  nil\n"
"    end\n"
"\n"
"    --mouse show/hide area\n"
"    for k,cords in pairs(osc_param.areas[\"showhide\"]) do\n"
"        set_virt_mouse_area(cords.x1, cords.y1, cords.x2, cords.y2, \"showhide\")\n"
"    end\n"
"    do_enable_keybindings()\n"
"\n"
"    --mouse input area\n"
"    local mouse_over_osc = false\n"
"\n"
"    for _,cords in ipairs(osc_param.areas[\"input\"]) do\n"
"        if state.osc_visible then -- activate only when OSC is actually visible\n"
"            set_virt_mouse_area(cords.x1, cords.y1, cords.x2, cords.y2, \"input\")\n"
"        end\n"
"        if state.osc_visible ~= state.input_enabled then\n"
"            if state.osc_visible then\n"
"                mp.enable_key_bindings(\"input\")\n"
"            else\n"
"                mp.disable_key_bindings(\"input\")\n"
"            end\n"
"            state.input_enabled = state.osc_visible\n"
"        end\n"
"\n"
"        if (mouse_hit_coords(cords.x1, cords.y1, cords.x2, cords.y2)) then\n"
"            mouse_over_osc = true\n"
"        end\n"
"    end\n"
"\n"
"    -- autohide\n"
"    if not (state.showtime == nil) and (user_opts.hidetimeout >= 0)\n"
"        and (state.showtime + (user_opts.hidetimeout/1000) < now)\n"
"        and (state.active_element == nil) and not (mouse_over_osc) then\n"
"\n"
"        hide_osc()\n"
"    end\n"
"\n"
"\n"
"    -- actual rendering\n"
"    local ass = assdraw.ass_new()\n"
"\n"
"    -- Messages\n"
"    render_message(ass)\n"
"\n"
"    -- actual OSC\n"
"    if state.osc_visible then\n"
"        render_elements(ass)\n"
"    end\n"
"\n"
"    -- submit\n"
"    mp.set_osd_ass(osc_param.playresy * osc_param.display_aspect,\n"
"                   osc_param.playresy, ass.text)\n"
"\n"
"\n"
"\n"
"\n"
"end\n"
"\n"
"--\n"
"-- Eventhandling\n"
"--\n"
"\n"
"local function element_has_action(element, action)\n"
"    return element and element.eventresponder and\n"
"        element.eventresponder[action]\n"
"end\n"
"\n"
"function process_event(source, what)\n"
"    local action = string.format(\"%s%s\", source,\n"
"        what and (\"_\" .. what) or \"\")\n"
"\n"
"    if what == \"down\" or what == \"press\" then\n"
"\n"
"        for n = 1, #elements do\n"
"\n"
"            if mouse_hit(elements[n]) and\n"
"                elements[n].eventresponder and\n"
"                (elements[n].eventresponder[source .. \"_up\"] or\n"
"                    elements[n].eventresponder[action]) then\n"
"\n"
"                if what == \"down\" then\n"
"                    state.active_element = n\n"
"                    state.active_event_source = source\n"
"                end\n"
"                -- fire the down or press event if the element has one\n"
"                if element_has_action(elements[n], action) then\n"
"                    elements[n].eventresponder[action](elements[n])\n"
"                end\n"
"\n"
"            end\n"
"        end\n"
"\n"
"    elseif what == \"up\" then\n"
"\n"
"        if elements[state.active_element] then\n"
"            local n = state.active_element\n"
"\n"
"            if n == 0 then\n"
"                --click on background (does not work)\n"
"            elseif element_has_action(elements[n], action) and\n"
"                mouse_hit(elements[n]) then\n"
"\n"
"                elements[n].eventresponder[action](elements[n])\n"
"            end\n"
"\n"
"            --reset active element\n"
"            if element_has_action(elements[n], \"reset\") then\n"
"                elements[n].eventresponder[\"reset\"](elements[n])\n"
"            end\n"
"\n"
"        end\n"
"        state.active_element = nil\n"
"        state.mouse_down_counter = 0\n"
"\n"
"    elseif source == \"mouse_move\" then\n"
"\n"
"        local mouseX, mouseY = get_virt_mouse_pos()\n"
"        if (user_opts.minmousemove == 0) or\n"
"            (not ((state.last_mouseX == nil) or (state.last_mouseY == nil)) and\n"
"                ((math.abs(mouseX - state.last_mouseX) >= user_opts.minmousemove)\n"
"                    or (math.abs(mouseY - state.last_mouseY) >= user_opts.minmousemove)\n"
"                )\n"
"            ) then\n"
"            show_osc()\n"
"        end\n"
"        state.last_mouseX, state.last_mouseY = mouseX, mouseY\n"
"\n"
"        local n = state.active_element\n"
"        if element_has_action(elements[n], action) then\n"
"            elements[n].eventresponder[action](elements[n])\n"
"        end\n"
"        tick()\n"
"    end\n"
"end\n"
"\n"
"-- called by mpv on every frame\n"
"function tick()\n"
"    if (not state.enabled) then return end\n"
"\n"
"    if (state.idle) then\n"
"\n"
"        -- render idle message\n"
"        msg.trace(\"idle message\")\n"
"        local icon_x, icon_y = 320 - 26, 140\n"
"\n"
"        local ass = assdraw.ass_new()\n"
"        ass:new_event()\n"
"        ass:pos(icon_x, icon_y)\n"
"        ass:append(\"{\\\\rDefault\\\\an7\\\\c&H430142&\\\\1a&H00&\\\\bord0\\\\shad0\\\\p6}m 1605 828 b 1605 1175 1324 1456 977 1456 631 1456 349 1175 349 828 349 482 631 200 977 200 1324 200 1605 482 1605 828{\\\\p0}\")\n"
"        ass:new_event()\n"
"        ass:pos(icon_x, icon_y)\n"
"        ass:append(\"{\\\\rDefault\\\\an7\\\\c&HDDDBDD&\\\\1a&H00&\\\\bord0\\\\shad0\\\\p6}m 1296 910 b 1296 1131 1117 1310 897 1310 676 1310 497 1131 497 910 497 689 676 511 897 511 1117 511 1296 689 1296 910{\\\\p0}\")\n"
"        ass:new_event()\n"
"        ass:pos(icon_x, icon_y)\n"
"        ass:append(\"{\\\\rDefault\\\\an7\\\\c&H691F69&\\\\1a&H00&\\\\bord0\\\\shad0\\\\p6}m 762 1113 l 762 708 b 881 776 1000 843 1119 911 1000 978 881 1046 762 1113{\\\\p0}\")\n"
"        ass:new_event()\n"
"        ass:pos(icon_x, icon_y)\n"
"        ass:append(\"{\\\\rDefault\\\\an7\\\\c&H682167&\\\\1a&H00&\\\\bord0\\\\shad0\\\\p6}m 925 42 b 463 42 87 418 87 880 87 1343 463 1718 925 1718 1388 1718 1763 1343 1763 880 1763 418 1388 42 925 42 m 925 42 m 977 200 b 1324 200 1605 482 1605 828 1605 1175 1324 1456 977 1456 631 1456 349 1175 349 828 349 482 631 200 977 200{\\\\p0}\")\n"
"        ass:new_event()\n"
"        ass:pos(icon_x, icon_y)\n"
"        ass:append(\"{\\\\rDefault\\\\an7\\\\c&H753074&\\\\1a&H00&\\\\bord0\\\\shad0\\\\p6}m 977 198 b 630 198 348 480 348 828 348 1176 630 1458 977 1458 1325 1458 1607 1176 1607 828 1607 480 1325 198 977 198 m 977 198 m 977 202 b 1323 202 1604 483 1604 828 1604 1174 1323 1454 977 1454 632 1454 351 1174 351 828 351 483 632 202 977 202{\\\\p0}\")\n"
"        ass:new_event()\n"
"        ass:pos(icon_x, icon_y)\n"
"        ass:append(\"{\\\\rDefault\\\\an7\\\\c&HE5E5E5&\\\\1a&H00&\\\\bord0\\\\shad0\\\\p6}m 895 10 b 401 10 0 410 0 905 0 1399 401 1800 895 1800 1390 1800 1790 1399 1790 905 1790 410 1390 10 895 10 m 895 10 m 925 42 b 1388 42 1763 418 1763 880 1763 1343 1388 1718 925 1718 463 1718 87 1343 87 880 87 418 463 42 925 42{\\\\p0}\")\n"
"        ass:new_event()\n"
"        ass:pos(320, icon_y+65)\n"
"        ass:an(8)\n"
"        ass:append(\"Drop files or URLs to play here.\")\n"
"        mp.set_osd_ass(640, 360, ass.text)\n"
"\n"
"        if state.showhide_enabled then\n"
"            mp.disable_key_bindings(\"showhide\")\n"
"            state.showhide_enabled = false\n"
"        end\n"
"\n"
"\n"
"    elseif (state.fullscreen and user_opts.showfullscreen)\n"
"        or (not state.fullscreen and user_opts.showwindowed) then\n"
"\n"
"        -- render the OSC\n"
"        render()\n"
"    else\n"
"        -- Flush OSD\n"
"        mp.set_osd_ass(osc_param.playresy, osc_param.playresy, \"\")\n"
"    end\n"
"end\n"
"\n"
"function do_enable_keybindings()\n"
"    if state.enabled then\n"
"        if not state.showhide_enabled then\n"
"            mp.enable_key_bindings(\"showhide\", \"allow-vo-dragging+allow-hide-cursor\")\n"
"        end\n"
"        state.showhide_enabled = true\n"
"    end\n"
"end\n"
"\n"
"function enable_osc(enable)\n"
"    state.enabled = enable\n"
"    if enable then\n"
"        do_enable_keybindings()\n"
"    else\n"
"        hide_osc() -- acts immediately when state.enabled == false\n"
"        if state.showhide_enabled then\n"
"            mp.disable_key_bindings(\"showhide\")\n"
"        end\n"
"        state.showhide_enabled = false\n"
"    end\n"
"end\n"
"\n"
"validate_user_opts()\n"
"\n"
"mp.register_event(\"start-file\", request_init)\n"
"mp.register_event(\"tracks-changed\", request_init)\n"
"mp.observe_property(\"playlist\", nil, request_init)\n"
"\n"
"mp.register_script_message(\"osc-message\", show_message)\n"
"mp.register_script_message(\"osc-chapterlist\", function(dur)\n"
"    show_message(get_chapterlist(), dur)\n"
"end)\n"
"mp.register_script_message(\"osc-playlist\", function(dur)\n"
"    show_message(get_playlist(), dur)\n"
"end)\n"
"mp.register_script_message(\"osc-tracklist\", function(dur)\n"
"    local msg = {}\n"
"    for k,v in pairs(nicetypes) do\n"
"        table.insert(msg, get_tracklist(k))\n"
"    end\n"
"    show_message(table.concat(msg, '\\n\\n'), dur)\n"
"end)\n"
"\n"
"mp.observe_property(\"fullscreen\", \"bool\",\n"
"    function(name, val)\n"
"        state.fullscreen = val\n"
"        request_init()\n"
"    end\n"
")\n"
"mp.observe_property(\"idle-active\", \"bool\",\n"
"    function(name, val)\n"
"        state.idle = val\n"
"        tick()\n"
"    end\n"
")\n"
"mp.observe_property(\"pause\", \"bool\", pause_state)\n"
"mp.observe_property(\"cache-idle\", \"bool\", cache_state)\n"
"mp.observe_property(\"vo-configured\", \"bool\", function(name, val)\n"
"    if val then\n"
"        mp.register_event(\"tick\", tick)\n"
"    else\n"
"        mp.unregister_event(tick)\n"
"    end\n"
"end)\n"
"\n"
"-- mouse show/hide bindings\n"
"mp.set_key_bindings({\n"
"    {\"mouse_move\",              function(e) process_event(\"mouse_move\", nil) end},\n"
"    {\"mouse_leave\",             mouse_leave},\n"
"}, \"showhide\", \"force\")\n"
"do_enable_keybindings()\n"
"\n"
"--mouse input bindings\n"
"mp.set_key_bindings({\n"
"    {\"mbtn_left\",           function(e) process_event(\"mbtn_left\", \"up\") end,\n"
"                            function(e) process_event(\"mbtn_left\", \"down\")  end},\n"
"    {\"shift+mbtn_left\",     function(e) process_event(\"shift+mbtn_left\", \"up\") end,\n"
"                            function(e) process_event(\"shift+mbtn_left\", \"down\")  end},\n"
"    {\"mbtn_right\",          function(e) process_event(\"mbtn_right\", \"up\") end,\n"
"                            function(e) process_event(\"mbtn_right\", \"down\")  end},\n"
"    {\"wheel_up\",            function(e) process_event(\"wheel_up\", \"press\") end},\n"
"    {\"wheel_down\",          function(e) process_event(\"wheel_down\", \"press\") end},\n"
"    {\"mbtn_left_dbl\",       \"ignore\"},\n"
"    {\"shift+mbtn_left_dbl\", \"ignore\"},\n"
"    {\"mbtn_right_dbl\",      \"ignore\"},\n"
"}, \"input\", \"force\")\n"
"mp.enable_key_bindings(\"input\")\n"
"\n"
"\n"
"user_opts.hidetimeout_orig = user_opts.hidetimeout\n"
"\n"
"function always_on(val)\n"
"    if val then\n"
"        user_opts.hidetimeout = -1 -- disable autohide\n"
"        if state.enabled then show_osc() end\n"
"    else\n"
"        user_opts.hidetimeout = user_opts.hidetimeout_orig\n"
"        if state.enabled then hide_osc() end\n"
"    end\n"
"end\n"
"\n"
"-- mode can be auto/always/never/cycle\n"
"-- the modes only affect internal variables and not stored on its own.\n"
"function visibility_mode(mode, no_osd)\n"
"    if mode == \"cycle\" then\n"
"        if not state.enabled then\n"
"            mode = \"auto\"\n"
"        elseif user_opts.hidetimeout >= 0 then\n"
"            mode = \"always\"\n"
"        else\n"
"            mode = \"never\"\n"
"        end\n"
"    end\n"
"\n"
"    if mode == \"auto\" then\n"
"        always_on(false)\n"
"        enable_osc(true)\n"
"    elseif mode == \"always\" then\n"
"        enable_osc(true)\n"
"        always_on(true)\n"
"    elseif mode == \"never\" then\n"
"        enable_osc(false)\n"
"    else\n"
"        msg.warn(\"Ignoring unknown visibility mode '\" .. mode .. \"'\")\n"
"        return\n"
"    end\n"
"\n"
"    if not no_osd and tonumber(mp.get_property(\"osd-level\")) >= 1 then\n"
"        mp.osd_message(\"OSC visibility: \" .. mode)\n"
"    end\n"
"end\n"
"\n"
"visibility_mode(user_opts.visibility, true)\n"
"mp.register_script_message(\"osc-visibility\", visibility_mode)\n"
"mp.add_key_binding(nil, \"visibility\", function() visibility_mode(\"cycle\") end)\n"
"\n"
"set_virt_mouse_area(0, 0, 0, 0, \"input\")\n"
