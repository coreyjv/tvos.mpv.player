// Generated from player/javascript/defaults.js

"\"use strict\";\n"
"(function main_default_js(g) {\n"
"// - g is the global object.\n"
"// - User callbacks called without 'this', global only if callee is non-strict.\n"
"// - The names of function expressions are not required, but are used in stack\n"
"//   traces. We name them where useful to show up (fname:#line always shows).\n"
"\n"
"mp.msg = { log: mp.log };\n"
"mp.msg.verbose = mp.log.bind(null, \"v\");\n"
"var levels = [\"fatal\", \"error\", \"warn\", \"info\", \"debug\", \"trace\"];\n"
"levels.forEach(function(l) { mp.msg[l] = mp.log.bind(null, l) });\n"
"\n"
"// same as {} but without inherited stuff, e.g. o[\"toString\"] doesn't exist.\n"
"// used where we try to fetch items by keys which we don't absolutely trust.\n"
"function new_cache() {\n"
"    return Object.create(null, {});\n"
"}\n"
"\n"
"/**********************************************************************\n"
" *  event handlers, property observers, idle, client messages, hooks\n"
" *********************************************************************/\n"
"var ehandlers = new_cache() // items of event-name: array of {maybe cb: fn}\n"
"\n"
"mp.register_event = function(name, fn) {\n"
"    if (!ehandlers[name])\n"
"        ehandlers[name] = [];\n"
"    ehandlers[name] = ehandlers[name].concat([{cb: fn}]);  // replaces the arr\n"
"    return mp._request_event(name, true);\n"
"}\n"
"\n"
"mp.unregister_event = function(fn) {\n"
"    for (var name in ehandlers) {\n"
"        ehandlers[name] = ehandlers[name].filter(function(h) {\n"
"                              if (h.cb != fn)\n"
"                                  return true;\n"
"                              delete h.cb;  // dispatch could have a ref to h\n"
"                          });  // replacing, not mutating the array\n"
"        if (!ehandlers[name].length) {\n"
"            delete ehandlers[name];\n"
"            mp._request_event(name, false);\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"// call only pre-registered handlers, but not ones which got unregistered\n"
"function dispatch_event(e) {\n"
"    var handlers = ehandlers[e.event];\n"
"    if (handlers) {\n"
"        for (var len = handlers.length, i = 0; i < len; i++) {\n"
"            var cb = handlers[i].cb;  // 'handlers' won't mutate, but unregister\n"
"            if (cb)                   // could remove cb from some items\n"
"                cb(e);\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"//  ----- idle observers -----\n"
"var iobservers = [],  // array of callbacks\n"
"    ideleted = false;\n"
"\n"
"mp.register_idle = function(fn) {\n"
"    iobservers.push(fn);\n"
"}\n"
"\n"
"mp.unregister_idle = function(fn) {\n"
"    iobservers.forEach(function(f, i) {\n"
"        if (f == fn)\n"
"             delete iobservers[i];  // -> same length but [more] sparse\n"
"    });\n"
"    ideleted = true;\n"
"}\n"
"\n"
"function notify_idle_observers() {\n"
"    // forEach and filter skip deleted items and newly added items\n"
"    iobservers.forEach(function(f) { f() });\n"
"    if (ideleted) {\n"
"        iobservers = iobservers.filter(function() { return true });\n"
"        ideleted = false;\n"
"    }\n"
"}\n"
"\n"
"//  ----- property observers -----\n"
"var next_oid = 1,\n"
"    observers = new_cache();  // items of id: fn\n"
"\n"
"mp.observe_property = function(name, format, fn) {\n"
"    var id = next_oid++;\n"
"    observers[id] = fn;\n"
"    return mp._observe_property(id, name, format || undefined);  // allow null\n"
"}\n"
"\n"
"mp.unobserve_property = function(fn) {\n"
"    for (var id in observers) {\n"
"        if (observers[id] == fn) {\n"
"            delete observers[id];\n"
"            mp._unobserve_property(id);\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"function notify_observer(e) {\n"
"    var cb = observers[e.id];\n"
"    if (cb)\n"
"        cb(e.name, e.data);\n"
"}\n"
"\n"
"//  -----  Client messages -----\n"
"var messages = new_cache();  // items of name: fn\n"
"\n"
"// overrides name. no libmpv API to reg/unreg specific messages.\n"
"mp.register_script_message = function(name, fn) {\n"
"    messages[name] = fn;\n"
"}\n"
"\n"
"mp.unregister_script_message = function(name) {\n"
"    delete messages[name];\n"
"}\n"
"\n"
"function dispatch_message(ev) {\n"
"    var cb = ev.args.length ? messages[ev.args[0]] : false;\n"
"    if (cb)\n"
"        cb.apply(null, ev.args.slice(1));\n"
"}\n"
"\n"
"//  ----- hooks -----\n"
"var hooks = [];  // array of callbacks, id is index+1\n"
"\n"
"function run_hook(ev) {\n"
"    var cb = ev.id > 0 && hooks[ev.id - 1];\n"
"    if (cb)\n"
"        cb();\n"
"    mp._hook_continue(ev.hook_id);\n"
"}\n"
"\n"
"mp.add_hook = function add_hook(name, pri, fn) {\n"
"    hooks.push(fn);\n"
"    // 50 (scripting docs default priority) maps to 0 (default in C API docs)\n"
"    return mp._hook_add(name, pri - 50, hooks.length);\n"
"}\n"
"\n"
"/**********************************************************************\n"
" *  key bindings\n"
" *********************************************************************/\n"
"// binds: items of (binding) name which are objects of:\n"
"// {cb: fn, forced: bool, maybe input: str, repeatable: bool, complex: bool}\n"
"var binds = new_cache();\n"
"\n"
"function dispatch_key_binding(name, state) {\n"
"    var cb = binds[name] ? binds[name].cb : false;\n"
"    if (cb)  // \"script-binding [<script_name>/]<name>\" command was invoked\n"
"        cb(state);\n"
"}\n"
"\n"
"function update_input_sections() {\n"
"    var def = [], forced = [];\n"
"    for (var n in binds)  // Array.join() will later skip undefined .input\n"
"        (binds[n].forced ? forced : def).push(binds[n].input);\n"
"\n"
"    var sect = \"input_\" + mp.script_name;\n"
"    mp.commandv(\"define-section\", sect, def.join(\"\\n\"), \"default\");\n"
"    mp.commandv(\"enable-section\", sect, \"allow-hide-cursor+allow-vo-dragging\");\n"
"\n"
"    sect = \"input_forced_\" + mp.script_name;\n"
"    mp.commandv(\"define-section\", sect, forced.join(\"\\n\"), \"force\");\n"
"    mp.commandv(\"enable-section\", sect, \"allow-hide-cursor+allow-vo-dragging\");\n"
"}\n"
"\n"
"// name/opts maybe omitted. opts: object with optional bool members: repeatable,\n"
"// complex, forced, or a string str which is evaluated as object {str: true}.\n"
"var next_bid = 1;\n"
"function add_binding(forced, key, name, fn, opts) {\n"
"    if (typeof name == \"function\") {  // as if \"name\" is not part of the args\n"
"        opts = fn;\n"
"        fn = name;\n"
"        name = \"__keybinding\" + next_bid++;  // new unique binding name\n"
"    }\n"
"    var key_data = {forced: forced};\n"
"    switch (typeof opts) {  // merge opts into key_data\n"
"        case \"string\": key_data[opts] = true; break;\n"
"        case \"object\": for (var o in opts) key_data[o] = opts[o];\n"
"    }\n"
"\n"
"    if (key_data.complex) {\n"
"        mp.register_script_message(name, function msg_cb() {\n"
"            fn({event: \"press\", is_mouse: false});\n"
"        });\n"
"        var KEY_STATES = { u: \"up\", d: \"down\", r: \"repeat\", p: \"press\" };\n"
"        key_data.cb = function key_cb(state) {\n"
"            fn({\n"
"                event: KEY_STATES[state[0]] || \"unknown\",\n"
"                is_mouse: state[1] == \"m\"\n"
"            });\n"
"        }\n"
"    } else {\n"
"        mp.register_script_message(name, fn);\n"
"        key_data.cb = function key_cb(state) {\n"
"            // Emulate the semantics at input.c: mouse emits on up, kb on down.\n"
"            // Also, key repeat triggers the binding again.\n"
"            var e = state[0],\n"
"                emit = (state[1] == \"m\") ? (e == \"u\") : (e == \"d\");\n"
"            if (emit || e == \"p\" || e == \"r\" && key_data.repeatable)\n"
"                fn();\n"
"        }\n"
"    }\n"
"\n"
"    if (key)\n"
"        key_data.input = key + \" script-binding \" + mp.script_name + \"/\" + name;\n"
"    binds[name] = key_data;  // used by user and/or our (key) script-binding\n"
"    update_input_sections();\n"
"}\n"
"\n"
"mp.add_key_binding = add_binding.bind(null, false);\n"
"mp.add_forced_key_binding = add_binding.bind(null, true);\n"
"\n"
"mp.remove_key_binding = function(name) {\n"
"    mp.unregister_script_message(name);\n"
"    delete binds[name];\n"
"    update_input_sections();\n"
"}\n"
"\n"
"/**********************************************************************\n"
" Timers: compatible HTML5 WindowTimers - set/clear Timeout/Interval\n"
" - Spec: https://www.w3.org/TR/html5/webappapis.html#timers\n"
" - Guaranteed to callback a-sync to [re-]insertion (event-loop wise).\n"
" - Guaranteed to callback by expiration order, or, if equal, by insertion order.\n"
" - Not guaranteed schedule accuracy, though intervals should have good average.\n"
" *********************************************************************/\n"
"\n"
"// pending 'timers' ordered by expiration: latest at index 0 (top fires first).\n"
"// Earlier timers are quicker to handle - just push/pop or fewer items to shift.\n"
"var next_tid = 1,\n"
"    timers = [],  // while in process_timers, just insertion-ordered (push)\n"
"    tset_is_push = false,  // signal set_timer that we're in process_timers\n"
"    tcanceled = false,  // or object of items timer-id: true\n"
"    now = mp.get_time_ms;  // just an alias\n"
"\n"
"function insert_sorted(arr, t) {\n"
"    for (var i = arr.length - 1; i >= 0 && t.when >= arr[i].when; i--)\n"
"        arr[i + 1] = arr[i];  // move up timers which fire earlier than t\n"
"    arr[i + 1] = t;  // i is -1 or fires later than t\n"
"}\n"
"\n"
"// args (is \"arguments\"): fn_or_str [,duration [,user_arg1 [, user_arg2 ...]]]\n"
"function set_timer(repeat, args) {\n"
"    var fos = args[0],\n"
"        duration = Math.max(0, (args[1] || 0)),  // minimum and default are 0\n"
"        t = {\n"
"            id: next_tid++,\n"
"            when: now() + duration,\n"
"            interval: repeat ? duration : -1,\n"
"            callback: (typeof fos == \"function\") ? fos : Function(fos),\n"
"            args: (args.length < 3) ? false : [].slice.call(args, 2),\n"
"        };\n"
"\n"
"    if (tset_is_push) {\n"
"        timers.push(t);\n"
"    } else {\n"
"        insert_sorted(timers, t);\n"
"    }\n"
"    return t.id;\n"
"}\n"
"\n"
"g.setTimeout  = function setTimeout()  { return set_timer(false, arguments) };\n"
"g.setInterval = function setInterval() { return set_timer(true,  arguments) };\n"
"\n"
"g.clearTimeout = g.clearInterval = function(id) {\n"
"    if (id < next_tid) {  // must ignore if not active timer id.\n"
"        if (!tcanceled)\n"
"            tcanceled = {};\n"
"        tcanceled[id] = true;\n"
"    }\n"
"}\n"
"\n"
"// arr: ordered timers array. ret: -1: no timers, 0: due, positive: ms to wait\n"
"function peek_wait(arr) {\n"
"    return arr.length ? Math.max(0, arr[arr.length - 1].when - now()) : -1;\n"
"}\n"
"\n"
"function peek_timers_wait() {\n"
"    return peek_wait(timers);  // must not be called while in process_timers\n"
"}\n"
"\n"
"// Callback all due non-canceled timers which were inserted before calling us.\n"
"// Returns wait in ms till the next timer (possibly 0), or -1 if nothing pends.\n"
"function process_timers() {\n"
"    var wait = peek_wait(timers);\n"
"    if (wait != 0)\n"
"        return wait;\n"
"\n"
"    var actives = timers;  // only process those already inserted by now\n"
"    timers = [];  // we'll handle added new timers at the end of processing.\n"
"    tset_is_push = true;  // signal set_timer to just push-insert\n"
"\n"
"    do {\n"
"        var t = actives.pop();\n"
"        if (tcanceled && tcanceled[t.id])\n"
"            continue;\n"
"\n"
"        if (t.args) {\n"
"            t.callback.apply(null, t.args);\n"
"        } else {\n"
"            (0, t.callback)();  // faster, nicer stack trace than t.cb.call()\n"
"        }\n"
"\n"
"        if (t.interval >= 0) {\n"
"            // allow 20 ms delay/clock-resolution/gc before we skip and reset\n"
"            t.when = Math.max(now() - 20, t.when + t.interval);\n"
"            timers.push(t);  // insertion order only\n"
"        }\n"
"    } while (peek_wait(actives) == 0);\n"
"\n"
"    // new 'timers' are insertion-ordered. remains of actives are fully ordered\n"
"    timers.forEach(function(t) { insert_sorted(actives, t) });\n"
"    timers = actives;  // now we're fully ordered again, and with all timers\n"
"    tset_is_push = false;\n"
"    if (tcanceled) {\n"
"        timers = timers.filter(function(t) { return !tcanceled[t.id] });\n"
"        tcanceled = false;\n"
"    }\n"
"    return peek_wait(timers);\n"
"}\n"
"\n"
"/**********************************************************************\n"
" CommonJS module/require\n"
"\n"
" Spec: http://wiki.commonjs.org/wiki/Modules/1.1.1\n"
" - All the mandatory requirements are implemented, all the unit tests pass.\n"
" - The implementation makes the following exception:\n"
"   - Allows the chars [~\100:\\\\] in module id for meta-dir/builtin/dos-drive/UNC.\n"
"\n"
" Implementation choices beyond the specification:\n"
" - A module may assign to module.exports (rather than only to exports).\n"
" - A module's 'this' is the global object, also if it sets strict mode.\n"
"   - No 'global'/'self'. Users can do \"this.global = this;\" before require(..)\n"
"   - A module has \"privacy of its top scope\", runs in its own function context.\n"
" - No id identity with symlinks - a valid choice which others make too.\n"
" - require(\"X\") always maps to \"X.js\" -> require(\"foo.js\") is file \"foo.js.js\".\n"
" - Global modules search paths are 'scripts/modules.js/' in mpv config dirs.\n"
" - A main script could e.g. require(\"./abc\") to load a non-global module.\n"
" - Module id supports mpv path enhancements, e.g. ~/foo, ~~/bar, ~~desktop/baz\n"
" *********************************************************************/\n"
"\n"
"// Internal meta top-dirs. Users should not rely on these names.\n"
"var MODULES_META = \"~~modules\",\n"
"    SCRIPTDIR_META = \"~~scriptdir\",  // relative script path -> meta absolute id\n"
"    main_script = mp.utils.split_path(mp.script_file);  // -> [ path, file ]\n"
"\n"
"function resolve_module_file(id) {\n"
"    var sep = id.indexOf(\"/\"),\n"
"        base = id.substring(0, sep),\n"
"        rest = id.substring(sep + 1) + \".js\";\n"
"\n"
"    if (base == SCRIPTDIR_META)\n"
"        return mp.utils.join_path(main_script[0], rest);\n"
"\n"
"    if (base == MODULES_META) {\n"
"        var path = mp.find_config_file(\"scripts/modules.js/\" + rest);\n"
"        if (!path)\n"
"            throw(Error(\"Cannot find module file '\" + rest + \"'\"));\n"
"        return path;\n"
"    }\n"
"\n"
"    return id + \".js\";\n"
"}\n"
"\n"
"// Delimiter '/', remove redundancies, prefix with modules meta-root if needed.\n"
"// E.g. c:\\x -> c:/x, or ./x//y/../z -> ./x/z, or utils/x -> ~~modules/utils/x .\n"
"function canonicalize(id) {\n"
"    var path = id.replace(/\\\\/g,\"/\").split(\"/\"),\n"
"        t = path[0],\n"
"        base = [];\n"
"\n"
"    // if not strictly relative then must be top-level. figure out base/rest\n"
"    if (t != \".\" && t != \"..\") {\n"
"        // global module if it's not fs-root/home/dos-drive/builtin/meta-dir\n"
"        if (!(t == \"\" || t == \"~\" || t[1] == \":\" ||  t == \"\100\" || t.match(/^~~/)))\n"
"            path.unshift(MODULES_META);  // add an explicit modules meta-root\n"
"\n"
"        if (id.match(/^\\\\\\\\/))  // simple UNC handling, preserve leading \\\\srv\n"
"            path = [\"\\\\\\\\\" + path[2]].concat(path.slice(3));  // [ \\\\srv, shr..]\n"
"\n"
"        if (t[1] == \":\" && t.length > 2) {  // path: [ \"c:relative\", \"path\" ]\n"
"            path[0] = t.substring(2);\n"
"            path.unshift(t[0] + \":.\");  //  ->  [ \"c:.\", \"relative\", \"path\" ]\n"
"        }\n"
"        base = [path.shift()];\n"
"    }\n"
"\n"
"    // path is now logically relative. base, if not empty, is its [meta] root.\n"
"    // normalize the relative part - always id-based (spec Module Id, 1.3.6).\n"
"    var cr = [];  // canonicalized relative\n"
"    for (var i = 0; i < path.length; i++) {\n"
"        if (path[i] == \".\" || path[i] == \"\")\n"
"            continue;\n"
"        if (path[i] == \"..\" && cr.length && cr[cr.length - 1] != \"..\") {\n"
"            cr.pop();\n"
"            continue;\n"
"        }\n"
"        cr.push(path[i]);\n"
"    }\n"
"\n"
"    if (!base.length && cr[0] != \"..\")\n"
"        base = [\".\"];  // relative and not ../<stuff> so must start with ./\n"
"    return base.concat(cr).join(\"/\");\n"
"}\n"
"\n"
"function resolve_module_id(base_id, new_id) {\n"
"    new_id = canonicalize(new_id);\n"
"    if (!new_id.match(/^\\.\\/|^\\.\\.\\//))  // doesn't start with ./ or ../\n"
"        return new_id;  // not relative, we don't care about base_id\n"
"\n"
"    var combined = mp.utils.join_path(mp.utils.split_path(base_id)[0], new_id);\n"
"    return canonicalize(combined);\n"
"}\n"
"\n"
"var req_cache = new_cache();  // global for all instances of require\n"
"\n"
"// ret: a require function instance which uses base_id to resolve relative id's\n"
"function new_require(base_id) {\n"
"    return function require(id) {\n"
"        id = resolve_module_id(base_id, id);  // id is now top-level\n"
"        if (req_cache[id])\n"
"            return req_cache[id].exports;\n"
"\n"
"        var new_module = {id: id, exports: {}};\n"
"        req_cache[id] = new_module;\n"
"        try {\n"
"            var filename = resolve_module_file(id);\n"
"            // we need dedicated free vars + filename in traces + allow strict\n"
"            var str = \"mp._req = function(require, exports, module) {\" +\n"
"                          mp.utils.read_file(filename) +\n"
"                      \"\\n;}\";\n"
"            mp.utils.compile_js(filename, str)();  // only runs the assignment\n"
"            var tmp = mp._req;  // we have mp._req, or else we'd have thrown\n"
"            delete mp._req;\n"
"            tmp.call(g, new_require(id), new_module.exports, new_module);\n"
"        } catch (e) {\n"
"            delete req_cache[id];\n"
"            throw(e);\n"
"        }\n"
"\n"
"        return new_module.exports;\n"
"    };\n"
"}\n"
"\n"
"g.require = new_require(SCRIPTDIR_META + \"/\" + main_script[1]);\n"
"\n"
"/**********************************************************************\n"
" *  mp.options\n"
" *********************************************************************/\n"
"function read_options(opts, id) {\n"
"    id = String(typeof id != \"undefined\" ? id : mp.get_script_name());\n"
"    mp.msg.debug(\"reading options for \" + id);\n"
"\n"
"    var conf, fname = \"~~/script-opts/\" + id + \".conf\";\n"
"    try {\n"
"        conf = mp.utils.read_file(fname);\n"
"    } catch (e) {\n"
"        mp.msg.verbose(fname + \" not found.\");\n"
"    }\n"
"\n"
"    // data as config file lines array, or empty array\n"
"    var data = conf ? conf.replace(/\\r\\n/g, \"\\n\").split(\"\\n\") : [],\n"
"        conf_len = data.length;  // before we append script-opts below\n"
"\n"
"    // Append relevant script-opts as <key-sans-id>=<value> to data\n"
"    var sopts = mp.get_property_native(\"options/script-opts\"),\n"
"        prefix = id + \"-\";\n"
"    for (var key in sopts) {\n"
"        if (key.indexOf(prefix) == 0)\n"
"            data.push(key.substring(prefix.length) + \"=\" + sopts[key]);\n"
"    }\n"
"\n"
"    // Update opts from data\n"
"    data.forEach(function(line, i) {\n"
"        if (line[0] == \"#\" || line.trim() == \"\")\n"
"            return;\n"
"\n"
"        var key = line.substring(0, line.indexOf(\"=\")),\n"
"            val = line.substring(line.indexOf(\"=\") + 1),\n"
"            type = typeof opts[key],\n"
"            info = i < conf_len ? fname + \":\" + (i + 1)  // 1-based line number\n"
"                                : \"script-opts:\" + prefix + key;\n"
"\n"
"        if (!opts.hasOwnProperty(key))\n"
"            mp.msg.warn(info, \"Ignoring unknown key '\" + key + \"'\");\n"
"        else if (type == \"string\")\n"
"            opts[key] = val;\n"
"        else if (type == \"boolean\" && (val == \"yes\" || val == \"no\"))\n"
"            opts[key] = (val == \"yes\");\n"
"        else if (type == \"number\" && val.trim() != \"\" && !isNaN(val))\n"
"            opts[key] = Number(val);\n"
"        else\n"
"            mp.msg.error(info, \"Error: can't convert '\" + val + \"' to \" + type);\n"
"    });\n"
"}\n"
"\n"
"mp.options = { read_options: read_options };\n"
"\n"
"/**********************************************************************\n"
" *  various\n"
" *********************************************************************/\n"
"g.print = mp.msg.info;  // convenient alias\n"
"mp.get_script_name = function() { return mp.script_name };\n"
"mp.get_script_file = function() { return mp.script_file };\n"
"mp.get_time = function() { return mp.get_time_ms() / 1000 };\n"
"mp.utils.getcwd = function() { return mp.get_property(\"working-directory\") };\n"
"mp.dispatch_event = dispatch_event;\n"
"mp.process_timers = process_timers;\n"
"mp.notify_idle_observers = notify_idle_observers;\n"
"mp.peek_timers_wait = peek_timers_wait;\n"
"\n"
"mp.get_opt = function(key, def) {\n"
"    var v = mp.get_property_native(\"options/script-opts\")[key];\n"
"    return (typeof v != \"undefined\") ? v : def;\n"
"}\n"
"\n"
"mp.osd_message = function osd_message(text, duration) {\n"
"    mp.commandv(\"show_text\", text, Math.round(1000 * (duration || -1)));\n"
"}\n"
"\n"
"// ----- dump: like print, but expands objects/arrays recursively -----\n"
"function replacer(k, v) {\n"
"    var t = typeof v;\n"
"    if (t == \"function\" || t == \"undefined\")\n"
"        return \"<\" + t + \">\";\n"
"    if (Array.isArray(this) && t == \"object\" && v !== null) {  // \"safe\" mode\n"
"        if (this.indexOf(v) >= 0)\n"
"            return \"<VISITED>\";\n"
"        this.push(v);\n"
"    }\n"
"    return v;\n"
"}\n"
"\n"
"function obj2str(v) {\n"
"    try {  // can process objects more than once, but throws on cycles\n"
"        return JSON.stringify(v, replacer.bind(null), 2);\n"
"    } catch (e) { // simple safe: exclude visited objects, even if not cyclic\n"
"        return JSON.stringify(v, replacer.bind([]), 2);\n"
"    }\n"
"}\n"
"\n"
"g.dump = function dump() {\n"
"    var toprint = [];\n"
"    for (var i = 0; i < arguments.length; i++) {\n"
"        var v = arguments[i];\n"
"        toprint.push((typeof v == \"object\") ? obj2str(v) : replacer(0, v));\n"
"    }\n"
"    print.apply(null, toprint);\n"
"}\n"
"\n"
"/**********************************************************************\n"
" *  main listeners and event loop\n"
" *********************************************************************/\n"
"mp.keep_running = true;\n"
"g.exit = function() { mp.keep_running = false };  // user-facing too\n"
"mp.register_event(\"shutdown\", g.exit);\n"
"mp.register_event(\"property-change\", notify_observer);\n"
"mp.register_event(\"hook\", run_hook);\n"
"mp.register_event(\"client-message\", dispatch_message);\n"
"mp.register_script_message(\"key-binding\", dispatch_key_binding);\n"
"\n"
"g.mp_event_loop = function mp_event_loop() {\n"
"    var wait = 0;  // seconds\n"
"    do {  // distapch events as long as they arrive, then do the timers/idle\n"
"        var e = mp.wait_event(wait);\n"
"        if (e.event != \"none\") {\n"
"            dispatch_event(e);\n"
"            wait = 0;  // poll the next one\n"
"        } else {\n"
"            wait = process_timers() / 1000;\n"
"            if (wait != 0) {\n"
"                notify_idle_observers();  // can add timers -> recalculate wait\n"
"                wait = peek_timers_wait() / 1000;\n"
"            }\n"
"        }\n"
"    } while (mp.keep_running);\n"
"};\n"
"\n"
"})(this)\n"
